<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  面试常见问题 1 · Colin&#39;s Blog
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Oyyko">
<meta name="description" content="部分内容为GPT的回答。
和红黑树的功能类似的还有哪些数据结构 Link to heading 红黑树是一种自平衡的二叉搜索树，它通过特定的属性和操作保持树的平衡，从而实现在最坏情况下仍能保持对数级别的查找、插入和删除时间复杂度。和红黑树提供相似功能的数据结构主要包括其他类型的自平衡二叉搜索树和一些特殊的数据结构，它们都能提供高效的查找、插入和删除操作。下面列出一些常见的例子：">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="面试常见问题 1"/>
<meta name="twitter:description" content="部分内容为GPT的回答。
和红黑树的功能类似的还有哪些数据结构 Link to heading 红黑树是一种自平衡的二叉搜索树，它通过特定的属性和操作保持树的平衡，从而实现在最坏情况下仍能保持对数级别的查找、插入和删除时间复杂度。和红黑树提供相似功能的数据结构主要包括其他类型的自平衡二叉搜索树和一些特殊的数据结构，它们都能提供高效的查找、插入和删除操作。下面列出一些常见的例子："/>

<meta property="og:title" content="面试常见问题 1" />
<meta property="og:description" content="部分内容为GPT的回答。
和红黑树的功能类似的还有哪些数据结构 Link to heading 红黑树是一种自平衡的二叉搜索树，它通过特定的属性和操作保持树的平衡，从而实现在最坏情况下仍能保持对数级别的查找、插入和删除时间复杂度。和红黑树提供相似功能的数据结构主要包括其他类型的自平衡二叉搜索树和一些特殊的数据结构，它们都能提供高效的查找、插入和删除操作。下面列出一些常见的例子：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://oyyko-old-projects.github.io/blog-coder-copy/posts/interview1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-07T23:37:30-07:00" />
<meta property="article:modified_time" content="2024-04-08T01:01:44-07:00" />




<link rel="canonical" href="https://oyyko-old-projects.github.io/blog-coder-copy/posts/interview1/">


<style>
@import url(//fonts.googleapis.com/css2?family=Lato&family=JetBrains+Mono&family=Noto+Sans+SC);
</style>

<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/blog-coder-copy/css/coder.min.4aa47e08823270231494db5e45db07ca1087851d1cf797b9ceef270927d26246.css" integrity="sha256-SqR&#43;CIIycCMUlNteRdsHyhCHhR0c95e5zu8nCSfSYkY=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/blog-coder-copy/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/blog-coder-copy">
      Colin&#39;s Blog
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/blog-coder-copy/about">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/blog-coder-copy/posts">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/blog-coder-copy/tags">Tags</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://oyyko-old-projects.github.io/blog-coder-copy/posts/interview1/">
              面试常见问题 1
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-04-07T23:37:30-07:00">
                2024-04-07
              </time>
          </div>
          
          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/blog-coder-copy/tags/c&#43;&#43;/">C&#43;&#43;</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/blog-coder-copy/tags/interview/">Interview</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        
        <hr>
        <i class="fa fa-book"></i> Table of Contents
               <div id="toc"> <nav id="TableOfContents">
  <ul>
    <li><a href="#和红黑树的功能类似的还有哪些数据结构">和红黑树的功能类似的还有哪些数据结构</a>
      <ul>
        <li><a href="#avl树">AVL树</a></li>
        <li><a href="#b树及其变种">B树及其变种</a></li>
        <li><a href="#splay树">Splay树</a></li>
        <li><a href="#treap">Treap</a></li>
        <li><a href="#skip-list">Skip List</a></li>
        <li><a href="#aa树">AA树</a></li>
      </ul>
    </li>
    <li><a href="#五千万个整数求和尽量降低时间消耗怎么做">五千万个整数求和，尽量降低时间消耗。怎么做？</a>
      <ul>
        <li><a href="#1-使用有效的数据结构">1. 使用有效的数据结构</a></li>
        <li><a href="#2-循环优化">2. 循环优化</a></li>
        <li><a href="#3-多线程或并行计算">3. 多线程或并行计算</a></li>
        <li><a href="#4-向量化运算">4. 向量化运算</a></li>
        <li><a href="#5-减少函数调用">5. 减少函数调用</a></li>
        <li><a href="#实践示例python-并行计算">实践示例（Python 并行计算）</a></li>
      </ul>
    </li>
    <li><a href="#static关键字在c中的作用">static关键字在C++中的作用</a>
      <ul>
        <li><a href="#1-控制局部变量的存储期">1. 控制局部变量的存储期</a></li>
        <li><a href="#2-控制全局变量的链接性">2. 控制全局变量的链接性</a></li>
        <li><a href="#3-类的静态成员">3. 类的静态成员</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#static-成员函数">Static 成员函数</a>
      <ul>
        <li><a href="#特性">特性</a></li>
        <li><a href="#使用场景">使用场景</a></li>
        <li><a href="#示例代码">示例代码</a></li>
      </ul>
    </li>
    <li><a href="#不同文件中的static变量的初始化顺序有规定吗">不同文件中的static变量的初始化顺序有规定吗</a>
      <ul>
        <li><a href="#单个编译单元内的初始化顺序">单个编译单元内的初始化顺序</a></li>
        <li><a href="#跨多个编译单元的初始化顺序">跨多个编译单元的初始化顺序</a></li>
        <li><a href="#静态初始化顺序问题的解决办法">静态初始化顺序问题的解决办法</a></li>
        <li><a href="#总结-1">总结</a></li>
      </ul>
    </li>
    <li><a href="#c单例模式代码">C++单例模式代码</a></li>
    <li><a href="#静态变量和线程安全的关系">静态变量和线程安全的关系？</a>
      <ul>
        <li><a href="#静态变量">静态变量</a></li>
        <li><a href="#线程安全">线程安全</a></li>
        <li><a href="#静态变量与线程安全">静态变量与线程安全</a></li>
        <li><a href="#保证线程安全的策略">保证线程安全的策略</a></li>
      </ul>
    </li>
    <li><a href="#输入url到网页显示的过程">输入url到网页显示的过程</a>
      <ul>
        <li><a href="#1-解析url">1. 解析URL</a></li>
        <li><a href="#2-域名解析dns查询">2. 域名解析（DNS查询）</a></li>
        <li><a href="#3-建立连接">3. 建立连接</a></li>
        <li><a href="#4-发送http请求">4. 发送HTTP请求</a></li>
        <li><a href="#5-服务器处理请求并响应">5. 服务器处理请求并响应</a></li>
        <li><a href="#6-浏览器渲染页面">6. 浏览器渲染页面</a></li>
        <li><a href="#7-后续处理">7. 后续处理</a></li>
      </ul>
    </li>
    <li><a href="#什么时候会返回404">什么时候会返回404</a>
      <ul>
        <li><a href="#1-url错误或拼写错误">1. URL错误或拼写错误</a></li>
        <li><a href="#2-资源被移动或删除">2. 资源被移动或删除</a></li>
        <li><a href="#3-服务器配置问题">3. 服务器配置问题</a></li>
        <li><a href="#4-域名解析错误">4. 域名解析错误</a></li>
        <li><a href="#5-链接过时">5. 链接过时</a></li>
        <li><a href="#6-权限问题">6. 权限问题</a></li>
        <li><a href="#应对404错误的措施">应对404错误的措施</a></li>
      </ul>
    </li>
    <li><a href="#tcp怎么实现可靠传输">TCP怎么实现可靠传输</a>
      <ul>
        <li><a href="#1-三次握手建立连接">1. 三次握手建立连接</a></li>
        <li><a href="#2-数据包排序">2. 数据包排序</a></li>
        <li><a href="#3-确认应答与超时重传">3. 确认应答与超时重传</a></li>
        <li><a href="#4-流量控制">4. 流量控制</a></li>
        <li><a href="#5-拥塞控制">5. 拥塞控制</a></li>
        <li><a href="#6-保活机制">6. 保活机制</a></li>
        <li><a href="#7-四次挥手断开连接">7. 四次挥手断开连接</a></li>
      </ul>
    </li>
    <li><a href="#tcp连接过多怎么办">TCP连接过多怎么办</a>
      <ul>
        <li><a href="#1-优化服务器配置">1. 优化服务器配置</a></li>
        <li><a href="#2-使用负载均衡">2. 使用负载均衡</a></li>
        <li><a href="#3-采用更高效的架构">3. 采用更高效的架构</a></li>
        <li><a href="#4-优化应用层">4. 优化应用层</a></li>
        <li><a href="#5-资源监控和自动扩展">5. 资源监控和自动扩展</a></li>
        <li><a href="#6-防御拒绝服务攻击">6. 防御拒绝服务攻击</a></li>
      </ul>
    </li>
    <li><a href="#为什么有ip地址还有mac地址">为什么有IP地址还有MAC地址</a>
      <ul>
        <li><a href="#ip地址">IP地址</a></li>
        <li><a href="#mac地址">MAC地址</a></li>
        <li><a href="#为什么两者都需要">为什么两者都需要</a></li>
      </ul>
    </li>
    <li><a href="#路由器有ip地址吗">路由器有IP地址吗</a>
      <ul>
        <li><a href="#局域网lan侧ip地址">局域网（LAN）侧IP地址</a></li>
        <li><a href="#广域网wan侧ip地址">广域网（WAN）侧IP地址</a></li>
        <li><a href="#管理ip地址">管理IP地址</a></li>
      </ul>
    </li>
    <li><a href="#内存泄露怎么解决">内存泄露怎么解决</a>
      <ul>
        <li><a href="#检测内存泄露">检测内存泄露</a></li>
        <li><a href="#定位内存泄露">定位内存泄露</a></li>
        <li><a href="#修复内存泄露">修复内存泄露</a></li>
      </ul>
    </li>
    <li><a href="#为什么要有虚拟内存空间">为什么要有虚拟内存空间</a>
      <ul>
        <li><a href="#1-内存扩展">1. 内存扩展</a></li>
        <li><a href="#2-进程隔离">2. 进程隔离</a></li>
        <li><a href="#3-内存管理简化">3. 内存管理简化</a></li>
        <li><a href="#4-内存保护">4. 内存保护</a></li>
        <li><a href="#5-数据共享">5. 数据共享</a></li>
        <li><a href="#6-物理内存优化">6. 物理内存优化</a></li>
        <li><a href="#7-支持多任务">7. 支持多任务</a></li>
      </ul>
    </li>
    <li><a href="#i是原子性的吗">i++是原子性的吗</a>
      <ul>
        <li><a href="#为什么i不是原子性的">为什么<code>i++</code>不是原子性的</a></li>
        <li><a href="#如何确保操作的原子性">如何确保操作的原子性</a></li>
      </ul>
    </li>
    <li><a href="#子类中变量初始化顺序和销毁顺序">子类中变量初始化顺序和销毁顺序</a>
      <ul>
        <li><a href="#java">Java</a></li>
        <li><a href="#c">C++</a></li>
      </ul>
    </li>
    <li><a href="#cpu如何实现除法">cpu如何实现除法</a>
      <ul>
        <li><a href="#1-长除法硬件实现">1. 长除法（硬件实现）</a></li>
        <li><a href="#2-逼近法硬件实现">2. 逼近法（硬件实现）</a></li>
        <li><a href="#3-查表法软件硬件辅助实现">3. 查表法（软件/硬件辅助实现）</a></li>
        <li><a href="#4-软件实现">4. 软件实现</a></li>
        <li><a href="#性能考虑">性能考虑</a></li>
      </ul>
    </li>
    <li><a href="#三个线程如何交替打印abc循环100次用c实现">三个线程如何交替打印ABC循环100次，用C++实现</a></li>
    <li><a href="#unique_lock是什么">unique_lock是什么</a>
      <ul>
        <li><a href="#主要特点和用途">主要特点和用途</a></li>
        <li><a href="#示例用法">示例用法</a></li>
      </ul>
    </li>
    <li><a href="#cv的条件变为真的时候谁来唤醒呢">CV的条件变为真的时候，谁来唤醒呢？</a>
      <ul>
        <li><a href="#示例场景">示例场景</a></li>
      </ul>
    </li>
    <li><a href="#如何实现断点续传">如何实现断点续传</a>
      <ul>
        <li><a href="#1-记录传输进度">1. 记录传输进度</a></li>
        <li><a href="#2-支持范围请求">2. 支持范围请求</a></li>
        <li><a href="#3-客户端请求特定数据块">3. 客户端请求特定数据块</a></li>
        <li><a href="#4-服务器响应范围请求">4. 服务器响应范围请求</a></li>
        <li><a href="#5-校验和完整性验证">5. 校验和完整性验证</a></li>
        <li><a href="#示例http断点续传">示例：HTTP断点续传</a></li>
        <li><a href="#实现注意事项">实现注意事项</a></li>
      </ul>
    </li>
    <li><a href="#explicit关键字在c中的作用">explicit关键字在C++中的作用</a>
      <ul>
        <li><a href="#隐式类型转换">隐式类型转换</a></li>
        <li><a href="#使用explicit防止隐式转换">使用<code>explicit</code>防止隐式转换</a></li>
        <li><a href="#explicit的作用域"><code>explicit</code>的作用域</a></li>
      </ul>
    </li>
    <li><a href="#链表和数组的区别">链表和数组的区别</a></li>
    <li><a href="#队列和栈的区别">队列和栈的区别</a></li>
    <li><a href="#二叉树先序遍历中序遍历后序遍历">二叉树先序遍历、中序遍历、后序遍历</a></li>
    <li><a href="#引用和指针的区别">引用和指针的区别</a></li>
    <li><a href="#usingtypedef和define有什么区别">using,typedef和define有什么区别</a>
      <ul>
        <li><a href="#typedef"><code>typedef</code></a></li>
        <li><a href="#using"><code>using</code></a></li>
        <li><a href="#define"><code>#define</code></a></li>
        <li><a href="#主要区别">主要区别</a></li>
      </ul>
    </li>
    <li><a href="#const修饰成员函数会怎么样可以有两个f其中一个带const另一个不带吗">const修饰成员函数会怎么样？可以有两个f(),其中一个带const,另一个不带吗?</a></li>
    <li><a href="#static定义的变量默认值是多少普通变量呢">static定义的变量默认值是多少？普通变量呢？</a></li>
    <li><a href="#extern有什么作用">extern有什么作用</a></li>
    <li><a href="#简述指针常量与常量指针区别">简述指针常量与常量指针区别</a></li>
    <li><a href="#构造函数能否为虚函数">构造函数能否为虚函数</a></li>
    <li><a href="#为什么基类的析构函数需要是序函数">为什么基类的析构函数需要是序函数？</a></li>
    <li><a href="#重载隐藏重写覆盖三者的区别">重载、隐藏、重写（覆盖）三者的区别？</a></li>
    <li><a href="#重载为什么改变参数就可以实现调用不同的函数">重载为什么改变参数就可以实现调用不同的函数？</a>
      <ul>
        <li><a href="#参数类型数量和顺序的不同">参数类型、数量和顺序的不同</a></li>
        <li><a href="#编译器的重载解析过程">编译器的重载解析过程</a></li>
        <li><a href="#重载的实用性">重载的实用性</a></li>
        <li><a href="#示例">示例</a></li>
      </ul>
    </li>
    <li><a href="#重载对链接有什么影响重载的底层实现">重载对链接有什么影响？重载的底层实现？</a>
      <ul>
        <li><a href="#名字修饰name-mangling">名字修饰（Name Mangling）</a></li>
        <li><a href="#链接阶段的影响">链接阶段的影响</a></li>
        <li><a href="#不同编译器的差异">不同编译器的差异</a></li>
      </ul>
    </li>
    <li><a href="#构造函数可以被重载么析构函数呢">构造函数可以被重载么？析构函数呢？</a></li>
    <li><a href="#new和malloc有什么区别">new和malloc有什么区别?</a></li>
    <li><a href="#new-operator和operator-new的区别">new operator和operator new的区别？</a>
      <ul>
        <li><a href="#new操作符"><code>new</code>操作符</a></li>
        <li><a href="#operator-new函数"><code>operator new</code>函数</a></li>
        <li><a href="#总结-2">总结</a></li>
      </ul>
    </li>
    <li><a href="#深入解析newoperator-newnewplacement-new">深入解析new、operator new、::new、placement new</a>
      <ul>
        <li><a href="#1-new操作符">1. <code>new</code>操作符</a></li>
        <li><a href="#2-operator-new函数">2. <code>operator new</code>函数</a></li>
        <li><a href="#3-new">3. <code>::new</code></a></li>
        <li><a href="#4-placement-new">4. Placement new</a></li>
        <li><a href="#总结-3">总结</a></li>
      </ul>
    </li>
    <li><a href="#虚函数表的结构是怎样的">虚函数表的结构是怎样的？</a></li>
    <li><a href="#ab两个类类中有虚函数c继承ab有几张虚函数表">A,B两个类，类中有虚函数。C继承AB，有几张虚函数表？</a></li>
    <li><a href="#为什么不应该在构造函数中调用虚函数">为什么不应该在构造函数中调用虚函数</a>
      <ul>
        <li><a href="#为什么不应该在构造函数中调用虚函数-1">为什么不应该在构造函数中调用虚函数</a></li>
        <li><a href="#示例-1">示例</a></li>
        <li><a href="#最佳实践">最佳实践</a></li>
        <li><a href="#1-对象构造的阶段性">1. 对象构造的阶段性</a></li>
        <li><a href="#2-安全性和一致性">2. 安全性和一致性</a></li>
        <li><a href="#3-设计上的限制">3. 设计上的限制</a></li>
        <li><a href="#替代方案">替代方案</a></li>
        <li><a href="#上面都是gpt下面是人话">上面都是GPT，下面是人话</a></li>
      </ul>
    </li>
    <li><a href="#静态函数可以是虚函数么为什么">静态函数可以是虚函数么？为什么？</a></li>
    <li><a href="#析构函数可以是纯虚函数么">析构函数可以是纯虚函数么？</a>
      <ul>
        <li><a href="#纯虚析构函数">纯虚析构函数</a></li>
        <li><a href="#示例-2">示例</a></li>
        <li><a href="#注意事项">注意事项</a></li>
      </ul>
    </li>
    <li><a href="#定义一个a-pa-new-a5-delete-pa-类a的构造函数和析构函数分别执行了几次">定义一个A* pa= new A[5]; delete pa; 类A的构造函数和析构函数分别执行了几次？</a></li>
    <li><a href="#reserve和resize的区别是什么">reserve和resize的区别是什么？</a></li>
    <li><a href="#智能指针有几种分别介绍一下他们的底层实现">智能指针有几种？分别介绍一下他们的底层实现？</a></li>
    <li><a href="#为什么需要智能指针">为什么需要智能指针</a></li>
    <li><a href="#你刚才说到循环引用那你口述一个循环引用的实例在你说的这个实例中那你怎么用weak_ptr来解决呢">你刚才说到循环引用，那你口述一个循环引用的实例。在你说的这个实例中，那你怎么用weak_ptr来解决呢？</a></li>
    <li><a href="#说一下lambda表达式的底层实现">说一下lambda表达式的底层实现</a>
      <ul>
        <li><a href="#lambda表达式的组成">Lambda表达式的组成</a></li>
        <li><a href="#底层实现细节">底层实现细节</a></li>
        <li><a href="#例子">例子</a></li>
        <li><a href="#总结-4">总结</a></li>
      </ul>
    </li>
    <li><a href="#深拷贝和浅拷贝的区别">深拷贝和浅拷贝的区别</a></li>
    <li><a href="#讲一下四种类型转换符">讲一下四种类型转换符？</a></li>
    <li><a href="#进程间通信">进程间通信</a></li>
    <li><a href="#线程间通信">线程间通信</a></li>
    <li><a href="#协程是什么">协程是什么？</a></li>
    <li><a href="#用户态和内核态区别">用户态和内核态区别</a></li>
    <li><a href="#死锁产生的原因及四个必要条件">死锁产生的原因及四个必要条件</a></li>
    <li><a href="#系统调用是什么有哪些系统调用">系统调用是什么，有哪些系统调用</a></li>
    <li><a href="#孤儿进程僵尸进程">孤儿进程、僵尸进程</a></li>
    <li><a href="#单核机器上写多线程程序是否需要考虑加锁为什么">单核机器上写多线程程序，是否需要考虑加锁，为什么？</a></li>
    <li><a href="#静态链接和动态链接">静态链接和动态链接</a></li>
    <li><a href="#硬链接和软链接">硬链接和软链接</a></li>
    <li><a href="#为什么是成倍扩容而不是等差扩容">为什么是成倍扩容，而不是等差扩容</a></li>
    <li><a href="#-范围解析运算符有哪些用法">:: 范围解析运算符有哪些用法</a></li>
    <li><a href="#inline关键字">inline关键字</a></li>
    <li><a href="#union关键字">union关键字</a></li>
    <li><a href="#using关键字用法">using关键字用法</a></li>
    <li><a href="#friend关键字">friend关键字</a></li>
    <li><a href="#volatile关键字">volatile关键字</a></li>
    <li><a href="#为避免对同一对象进行赋值操作this指针用法">为避免对同一对象进行赋值操作，this指针，用法</a>
      <ul>
        <li><a href="#自赋值检查的工作原理">自赋值检查的工作原理</a></li>
        <li><a href="#为什么要避免自赋值">为什么要避免自赋值</a></li>
      </ul>
    </li>
    <li><a href="#什么是copy-on-write">什么是copy on write</a></li>
    <li><a href="#模板特化与偏特化">模板特化与偏特化</a>
      <ul>
        <li><a href="#模板特化template-specialization">模板特化（Template Specialization）</a></li>
        <li><a href="#模板偏特化partial-specialization">模板偏特化（Partial Specialization）</a></li>
        <li><a href="#区别总结">区别总结</a></li>
      </ul>
    </li>
    <li><a href="#为什么函数模板不支持偏特化">为什么函数模板不支持偏特化</a></li>
    <li><a href="#写一个宏版本的min">写一个宏版本的MIN</a></li>
    <li><a href="#auto作为返回值和模板一起怎么用">auto作为返回值和模板一起怎么用</a></li>
    <li><a href="#tcp和udp区别">TCP和UDP区别</a></li>
    <li><a href="#c-类对象的初始化顺序有多重继承情况下的顺序">C++ 类对象的初始化顺序，有多重继承情况下的顺序</a></li>
    <li><a href="#如果三次握手时候每次握手信息对方没收到会怎么样简答">如果三次握手时候每次握手信息对方没收到会怎么样，简答</a></li>
    <li><a href="#avl-和红黑树的差别">AVL 和红黑树的差别</a></li>
    <li><a href="#数据库事务的特点">数据库事务的特点</a></li>
    <li><a href="#虚拟地址如何转为物理地址">虚拟地址如何转为物理地址</a></li>
    <li><a href="#说一下滑动窗口如果接收方滑动窗口满了发送方会怎么做">说一下滑动窗口，如果接收方滑动窗口满了，发送方会怎么做</a></li>
    <li><a href="#页面置换算法">页面置换算法</a></li>
    <li><a href="#既然有了mallocfreec中为什么还需要newdelete呢">既然有了malloc/free，C++中为什么还需要new/delete呢？</a></li>
    <li><a href="#delete怎么实现">delete[]怎么实现</a></li>
    <li><a href="#计算类的sizeof">计算类的sizeof</a></li>
    <li><a href="#解决哈希冲突的方式">解决哈希冲突的方式？</a></li>
    <li><a href="#结构体内存对齐方式和为什么要进行内存对齐">结构体内存对齐方式和为什么要进行内存对齐？</a></li>
    <li><a href="#调试程序的方法">调试程序的方法</a></li>
    <li><a href="#遇到coredump要怎么调试">遇到coredump要怎么调试</a></li>
    <li><a href="#成员初始化列表的概念为什么用成员初始化列表会快一些性能优势">成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</a></li>
    <li><a href="#有三种情况是必须使用成员初始化列表进行初始化">有三种情况是必须使用成员初始化列表进行初始化</a></li>
    <li><a href="#c的调用惯例简单一点c函数调用的压栈过程">C++的调用惯例（简单一点C++函数调用的压栈过程）</a></li>
    <li><a href="#一个函数或者可执行文件的生成过程或者编译过程是怎样的">一个函数或者可执行文件的生成过程或者编译过程是怎样的</a></li>
    <li><a href="#定义和声明的区别">定义和声明的区别</a></li>
    <li><a href="#被free回收的内存是立即返还给操作系统吗为什么">被free回收的内存是立即返还给操作系统吗？为什么</a></li>
    <li><a href="#引用作为函数参数以及返回值的好处">引用作为函数参数以及返回值的好处</a></li>
    <li><a href="#建立tcp服务器的各个系统调用">建立TCP服务器的各个系统调用</a></li>
    <li><a href="#tcp和udp相关的协议与端口号">TCP和UDP相关的协议与端口号</a></li>
    <li><a href="#http的请求方法有哪些get和post的区别">http的请求方法有哪些？get和post的区别。</a></li>
    <li><a href="#tcp三次握手时的第一次的seq序号是怎样产生的">TCP三次握手时的第一次的seq序号是怎样产生的</a></li>
    <li><a href="#一个机器能够使用的端口号上限是多少为什么可以改变吗那如果想要用的端口超过这个限制怎么办">一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</a></li>
    <li><a href="#对称密码和非对称密码体系">对称密码和非对称密码体系</a></li>
    <li><a href="#数字证书是什么">数字证书是什么？</a></li>
    <li><a href="#服务器出现大量close_wait的连接的原因以及解决方法">服务器出现大量close_wait的连接的原因以及解决方法</a></li>
    <li><a href="#消息摘要算法列举一下介绍md5算法为什么md5是不可逆的有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢">消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？</a></li>
    <li><a href="#介绍一下ping的过程分别用到了哪些协议">介绍一下ping的过程，分别用到了哪些协议</a></li>
    <li><a href="#tcpip的粘包与避免介绍一下">TCP/IP的粘包与避免介绍一下</a></li>
    <li><a href="#一个ip配置多个域名靠什么识别">一个ip配置多个域名，靠什么识别？</a></li>
    <li><a href="#dns的工作过程和原理">DNS的工作过程和原理</a></li>
    <li><a href="#arp协议">ARP协议</a></li>
    <li><a href="#关系型和非关系型数据库的区别">关系型和非关系型数据库的区别</a></li>
    <li><a href="#说一下-mysql-执行一条查询语句的内部执行过程">说一下 MySQL 执行一条查询语句的内部执行过程？</a></li>
    <li><a href="#数据库的索引类型有哪些">数据库的索引类型有哪些</a></li>
    <li><a href="#说一下事务是怎么实现的">说一下事务是怎么实现的</a></li>
    <li><a href="#mysql怎么建立索引怎么建立主键索引怎么删除索引">MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</a></li>
    <li><a href="#索引的优缺点什么时候使用索引什么时候不能使用索引">索引的优缺点，什么时候使用索引，什么时候不能使用索引</a></li>
    <li><a href="#索引的底层实现">索引的底层实现</a></li>
    <li><a href="#b树和b树的区别">B树和B+树的区别</a></li>
    <li><a href="#mysql的优化">Mysql的优化</a>
      <ul>
        <li><a href="#高频访问">高频访问</a></li>
        <li><a href="#并发优化">并发优化</a></li>
      </ul>
    </li>
    <li><a href="#索引最左前缀最左匹配">索引最左前缀/最左匹配</a></li>
    <li><a href="#数据库中事务的acid">数据库中事务的ACID</a></li>
    <li><a href="#什么是脏读不可重复读和幻读">什么是脏读，不可重复读和幻读？</a></li>
    <li><a href="#数据库的隔离级别mysql和oracle的隔离级别分别是什么">数据库的隔离级别，mysql和Oracle的隔离级别分别是什么</a></li>
    <li><a href="#mysql的表空间方式各自特点">Mysql的表空间方式，各自特点</a></li>
    <li><a href="#数据库的范式">数据库的范式</a></li>
    <li><a href="#乐观锁与悲观锁解释一下">乐观锁与悲观锁解释一下</a></li>
    <li><a href="#乐观锁与悲观锁是怎么实现的">乐观锁与悲观锁是怎么实现的</a></li>
    <li><a href="#linux的io模型介绍以及同步异步阻塞非阻塞的区别">Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别</a></li>
    <li><a href="#文件系统的理解ext4xfsbtrfs">文件系统的理解（EXT4，XFS，BTRFS）</a></li>
    <li><a href="#什么是io多路复用">什么是IO多路复用</a></li>
    <li><a href="#io复用的三种方法selectpollepoll深入理解包括三者区别内部原理实现">IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</a></li>
    <li><a href="#epoll的et模式和lt模式et的非阻塞">Epoll的ET模式和LT模式（ET的非阻塞）</a></li>
    <li><a href="#文件权限怎么看rwx">文件权限怎么看（rwx）</a></li>
    <li><a href="#文件的三种时间mtime-atimectime分别在什么时候会改变">文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</a></li>
    <li><a href="#linux监控网络带宽的命令查看特定进程的占用网络资源情况命令">Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</a></li>
    <li><a href="#怎么修改一个文件的权限">怎么修改一个文件的权限</a></li>
    <li><a href="#coredump是什么-怎么才能coredump">coredump是什么 怎么才能coredump</a></li>
    <li><a href="#linux理论上最多可以创建多少个进程一个进程可以创建多少线程和什么有关">Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</a></li>
    <li><a href="#冯诺依曼结构有哪几个模块分别对应现代计算机的哪几个部分">冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</a></li>
    <li><a href="#进程之间的通信方法有哪几种">进程之间的通信方法有哪几种</a></li>
    <li><a href="#进程调度方法详细介绍">进程调度方法详细介绍</a></li>
    <li><a href="#什么是饥饿">什么是饥饿</a></li>
    <li><a href="#可重入函数是什么">可重入函数是什么</a></li>
    <li><a href="#内核空间和用户空间是怎样区分的">内核空间和用户空间是怎样区分的</a></li>
    <li><a href="#同一个进程内的线程会共享什么资源">同一个进程内的线程会共享什么资源？</a></li>
    <li><a href="#brk和mmap是什么">brk和mmap是什么</a></li>
    <li><a href="#什么是字节序怎么判断是大端还是小端有什么用">什么是字节序？怎么判断是大端还是小端？有什么用？</a></li>
    <li><a href="#写单例模式线程安全版本">写单例模式，线程安全版本</a></li>
    <li><a href="#写三个线程交替打印abc">写三个线程交替打印ABC</a></li>
    <li><a href="#二维码登录的实现过程">二维码登录的实现过程</a></li>
    <li><a href="#不使用临时变量实现swap函数">不使用临时变量实现swap函数</a></li>
    <li><a href="#找到数组里第k大的数字">找到数组里第k大的数字</a></li>
    <li><a href="#top-k问题">Top K问题</a></li>
    <li><a href="#b树-b树">B树 B+树</a></li>
    <li><a href="#怎么写sql取表的前1000行数据">怎么写sql取表的前1000行数据</a></li>
    <li><a href="#布隆过滤器">布隆过滤器</a></li>
    <li><a href="#实现一个队列并且使它支持多线程">实现一个队列，并且使它支持多线程</a></li>
    <li><a href="#100层楼只有2个鸡蛋想要判断出那一层刚好让鸡蛋碎掉给出策略">100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略</a></li>
    <li><a href="#毒药问题1000瓶水其中有一瓶可以无限稀释的毒药要快速找出哪一瓶有毒需要几只小白鼠">毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</a></li>
    <li><a href="#先手必胜策略问题100本书每次能够拿1-5本怎么拿能保证最后一次是你拿">先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</a></li>
    <li><a href="#放n只蚂蚁在一条树枝上蚂蚁与蚂蚁之间碰到就各自往反方向走问总距离或者时间">放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</a></li>
    <li><a href="#瓶子换饮料问题1000瓶饮料3个空瓶子能够换1瓶饮料问最多能喝几瓶">瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</a></li>
    <li><a href="#在24小时里面时针分针秒针可以重合几次">在24小时里面时针分针秒针可以重合几次</a></li>
    <li><a href="#生成随机数问题给定生成1到5的随机数rand5如何得到生成1到7的随机数函数rand7">生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</a></li>
    <li><a href="#蓄水池采样算法">蓄水池采样算法</a></li>
    <li><a href="#赛马有25匹马每场比赛只能赛5匹至少要赛多少场才能找到最快的3匹马">赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</a></li>
    <li><a href="#烧-香绳子其他-确定时间问题有两根不均匀的香燃烧完都需要一个小时问怎么确定15分钟的时长">烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</a></li>
    <li><a href="#掰巧克力问题-nm块巧克力每次掰一块的一行或一列掰成11的巧克力需要多少次1000个人参加辩论赛1v1输了就退出需要安排多少场比赛快手提前批">掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）（快手提前批）</a></li>
    <li><a href="#介绍一下hadoop">介绍一下Hadoop</a></li>
    <li><a href="#说一下mapreduce的运行机制">说一下MapReduce的运行机制</a></li>
    <li><a href="#消息队列是什么">消息队列是什么</a></li>
    <li><a href="#为什么kafka吞吐量高介绍一下零拷贝">为什么kafka吞吐量高？/介绍一下零拷贝</a></li>
    <li><a href="#spark是什么">spark是什么</a></li>
    <li><a href="#kafka如何选举leader">kafka如何选举leader</a></li>
    <li><a href="#斐波那契数列第n项olog-n求出">斐波那契数列第n项，O(log n)求出</a></li>
    <li><a href="#react的特点以及数据流向diff算法主要做了啥">react的特点以及数据流向，diff算法主要做了啥？</a></li>
    <li><a href="#内存为什么要分段分段就只是为了方便程序员吗">内存为什么要分段？分段就只是为了方便程序员吗？</a></li>
    <li><a href="#https可以防止dns劫持吗">https可以防止DNS劫持吗？</a></li>
    <li><a href="#设计一款聊天软件你打算采用什么方案">设计一款聊天软件，你打算采用什么方案？</a></li>
    <li><a href="#cpu3级缓存">cpu3级缓存</a></li>
    <li><a href="#快表tlb是什么">快表（TLB）是什么</a></li>
    <li><a href="#http无状态优劣cookie">http无状态优劣—cookie</a></li>
    <li><a href="#什么是局部性原理">什么是局部性原理</a></li>
    <li><a href="#rabbitmq怎么用的">rabbitMQ怎么用的</a></li>
    <li><a href="#redis怎么用的">redis怎么用的</a></li>
    <li><a href="#数据库中哪些地方用了链表">数据库中哪些地方用了链表</a></li>
    <li><a href="#http了解吗怎么样不用框架用原生语言解析请求的json数据">HTTP了解吗，怎么样不用框架用原生语言解析请求的Json数据</a></li>
    <li><a href="#怎么样用数据结构和算法写一个定时器">怎么样用数据结构和算法写一个定时器</a></li>
    <li><a href="#tcp是怎么样超时重传的">tcp是怎么样超时重传的</a></li>
    <li><a href="#mqtt">MQTT</a></li>
    <li><a href="#webserver-项目中如果所有线程都在工作收到请求怎么做">webserver 项目中如果所有线程都在工作，收到请求怎么做？</a></li>
    <li><a href="#python-routine">python routine</a></li>
    <li><a href="#自己写一个协程控制器包括添加协程暂停等功能">自己写一个协程控制器，包括添加协程，暂停等功能</a></li>
    <li><a href="#写个生产者消费者模型">写个生产者消费者模型</a></li>
    <li><a href="#线程安全的数据结构">线程安全的数据结构</a></li>
    <li><a href="#线程池的创建方法">线程池的创建方法</a></li>
    <li><a href="#c反射是什么">C++反射是什么</a></li>
    <li><a href="#https加密协商出来的密钥的类型是什么">https加密协商出来的密钥的类型是什么</a></li>
    <li><a href="#海量数据问题">海量数据问题</a></li>
    <li><a href="#c问题大全">C++问题大全</a></li>
  </ul>
</nav> </div>
        <hr>
        <p>部分内容为GPT的回答。</p>
<h2 id="和红黑树的功能类似的还有哪些数据结构">
  和红黑树的功能类似的还有哪些数据结构
  <a class="heading-link" href="#%e5%92%8c%e7%ba%a2%e9%bb%91%e6%a0%91%e7%9a%84%e5%8a%9f%e8%83%bd%e7%b1%bb%e4%bc%bc%e7%9a%84%e8%bf%98%e6%9c%89%e5%93%aa%e4%ba%9b%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>红黑树是一种自平衡的二叉搜索树，它通过特定的属性和操作保持树的平衡，从而实现在最坏情况下仍能保持对数级别的查找、插入和删除时间复杂度。和红黑树提供相似功能的数据结构主要包括其他类型的自平衡二叉搜索树和一些特殊的数据结构，它们都能提供高效的查找、插入和删除操作。下面列出一些常见的例子：</p>
<h3 id="avl树">
  AVL树
  <a class="heading-link" href="#avl%e6%a0%91">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>AVL树是最早被发明的自平衡二叉搜索树之一。它严格保持二叉树的平衡，即任何节点的两个子树的高度最大差为1。这种严格的平衡要求使得AVL树在查找操作中表现得非常好，但在频繁的插入和删除操作中可能会有较多的旋转调整，相比于红黑树可能略显低效。</p>
<h3 id="b树及其变种">
  B树及其变种
  <a class="heading-link" href="#b%e6%a0%91%e5%8f%8a%e5%85%b6%e5%8f%98%e7%a7%8d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>B树是一种平衡的多路搜索树，主要用于数据库和文件系统。B树通过将节点中存储多个元素并允许节点有多个子节点来减少树的高度，从而优化磁盘读写操作。B+树和B*树是B树的变种，它们在B树的基础上做了进一步的优化，广泛应用于数据库索引。</p>
<h3 id="splay树">
  Splay树
  <a class="heading-link" href="#splay%e6%a0%91">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Splay树是一种自调整的二叉搜索树，它通过一种称为“伸展”的操作来保证最近进行的操作可以在较快的时间内完成。伸展树不保证树的严格平衡，但它能保证分摊的时间复杂度为O(log n)。</p>
<h3 id="treap">
  Treap
  <a class="heading-link" href="#treap">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Treap是一种结合了二叉搜索树和堆的数据结构，节点既按键排序又按优先级堆组织。它利用旋转操作来维持二叉搜索树的性质和堆的性质，实现了平衡树的效果。</p>
<h3 id="skip-list">
  Skip List
  <a class="heading-link" href="#skip-list">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>跳跃表是一种概率性的数据结构，通过在多层链表上添加“快速通道”来实现快速查找。虽然不是树结构，跳跃表在功能上与红黑树相似，提供了高效的查找、插入和删除操作，其平均时间和空间复杂度都是O(log n)。跳跃表的实现相比于红黑树和AVL树更为简单，易于理解和实现。</p>
<h3 id="aa树">
  AA树
  <a class="heading-link" href="#aa%e6%a0%91">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>AA树是一种变种的红黑树，它简化了红黑树的平衡规则和旋转操作。通过限制只有右链接可以是红色，AA树使得实现变得更加简单，同时保持了与红黑树相似的操作性能。</p>
<p>这些数据结构各有特点，适用于不同的场景。选择合适的数据结构需要根据实际的应用场景和性能要求来决定。</p>
<h2 id="五千万个整数求和尽量降低时间消耗怎么做">
  五千万个整数求和，尽量降低时间消耗。怎么做？
  <a class="heading-link" href="#%e4%ba%94%e5%8d%83%e4%b8%87%e4%b8%aa%e6%95%b4%e6%95%b0%e6%b1%82%e5%92%8c%e5%b0%bd%e9%87%8f%e9%99%8d%e4%bd%8e%e6%97%b6%e9%97%b4%e6%b6%88%e8%80%97%e6%80%8e%e4%b9%88%e5%81%9a">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>对于五千万个整数求和的问题，主要目标是优化时间复杂度和减少执行时间。以下是一些优化策略，可以帮助提高求和操作的效率：</p>
<h3 id="1-使用有效的数据结构">
  1. 使用有效的数据结构
  <a class="heading-link" href="#1-%e4%bd%bf%e7%94%a8%e6%9c%89%e6%95%88%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>确保整数存储在连续的内存空间中，比如使用数组或列表，这样可以减少内存访问的开销。</li>
</ul>
<h3 id="2-循环优化">
  2. 循环优化
  <a class="heading-link" href="#2-%e5%be%aa%e7%8e%af%e4%bc%98%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>尽可能使用高效的循环结构，减少循环内不必要的计算和条件判断。</li>
</ul>
<h3 id="3-多线程或并行计算">
  3. 多线程或并行计算
  <a class="heading-link" href="#3-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%88%96%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>利用现代计算机多核心的优势，可以将五千万个整数分成几个部分，每个核心处理一部分数据，然后将结果汇总。这种方式可以大大减少总的计算时间。</li>
<li>使用如OpenMP、Intel TBB（Thread Building Blocks）、Python的<code>concurrent.futures</code>模块或Java的<code>java.util.concurrent</code>包等并行框架和库来简化多线程编程的复杂性。</li>
</ul>
<h3 id="4-向量化运算">
  4. 向量化运算
  <a class="heading-link" href="#4-%e5%90%91%e9%87%8f%e5%8c%96%e8%bf%90%e7%ae%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>在支持向量化的编程语言中（如使用NumPy库的Python），可以利用向量化运算来提高性能，因为这些运算是在底层进行优化的。</li>
</ul>
<h3 id="5-减少函数调用">
  5. 减少函数调用
  <a class="heading-link" href="#5-%e5%87%8f%e5%b0%91%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>在求和过程中尽量减少函数调用，比如避免在循环中调用函数，因为函数调用会增加额外的时间开销。</li>
</ul>
<h3 id="实践示例python-并行计算">
  实践示例（Python 并行计算）
  <a class="heading-link" href="#%e5%ae%9e%e8%b7%b5%e7%a4%ba%e4%be%8bpython-%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>这里是一个使用Python的<code>concurrent.futures</code>模块进行并行计算求和的简单例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#f92672">import</span> concurrent.futures
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">parallel_sum</span>(arr, n_workers<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>    <span style="color:#75715e"># 分割数组为多个子数组</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>    chunk_size <span style="color:#f92672">=</span> len(arr) <span style="color:#f92672">//</span> n_workers
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>    futures <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>    <span style="color:#66d9ef">with</span> concurrent<span style="color:#f92672">.</span>futures<span style="color:#f92672">.</span>ThreadPoolExecutor(max_workers<span style="color:#f92672">=</span>n_workers) <span style="color:#66d9ef">as</span> executor:
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_workers):
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>            chunk <span style="color:#f92672">=</span> arr[i<span style="color:#f92672">*</span>chunk_size : (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>chunk_size]
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>            futures<span style="color:#f92672">.</span>append(executor<span style="color:#f92672">.</span>submit(np<span style="color:#f92672">.</span>sum, chunk))
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>    
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    <span style="color:#75715e"># 收集结果</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>    result <span style="color:#f92672">=</span> sum(f<span style="color:#f92672">.</span>result() <span style="color:#66d9ef">for</span> f <span style="color:#f92672">in</span> futures)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span><span style="color:#75715e"># 生成五千万个整数的数组</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>arr <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">50000000</span>)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>result <span style="color:#f92672">=</span> parallel_sum(arr)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>print(result)
</span></span></code></pre></div><p>这个例子展示了如何使用Python的并发特性和NumPy库来提高求和操作的效率。通过将数据分割成多个块并并行计算每个块的和，然后再将这些和加起来，可以显著减少计算所需的时间。注意，实际效果会根据你的硬件配置、Python版本和其他因素而有所不同。</p>
<h2 id="static关键字在c中的作用">
  static关键字在C++中的作用
  <a class="heading-link" href="#static%e5%85%b3%e9%94%ae%e5%ad%97%e5%9c%a8c%e4%b8%ad%e7%9a%84%e4%bd%9c%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，<code>static</code>关键字有几个不同的用途，根据其应用的上下文，它可以用于控制变量的存储期（生命周期）、可见性（链接性）、以及在类定义中控制成员的属性。以下是<code>static</code>在不同情况下的用法概述：</p>
<h3 id="1-控制局部变量的存储期">
  1. 控制局部变量的存储期
  <a class="heading-link" href="#1-%e6%8e%a7%e5%88%b6%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%9a%84%e5%ad%98%e5%82%a8%e6%9c%9f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在函数内部声明的局部变量通常在函数调用时创建，在函数返回时销毁。如果将局部变量声明为<code>static</code>，则该变量的生命周期会被延长到程序的整个运行期间，即使它的作用域仍然局限于声明它的那个函数内部。这意味着函数在多次调用之间可以保留变量的值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// counter的值在函数调用之间保持
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#75715e"></span>    counter<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> counter <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>}
</span></span></code></pre></div><h3 id="2-控制全局变量的链接性">
  2. 控制全局变量的链接性
  <a class="heading-link" href="#2-%e6%8e%a7%e5%88%b6%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e7%9a%84%e9%93%be%e6%8e%a5%e6%80%a7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在文件范围内声明的<code>static</code>变量或函数，其链接性为内部的（internal linkage），这意味着它们只在定义它们的文件内可见，对其他文件是隐藏的。这有助于避免命名冲突，并保护数据不被其他文件意外访问或修改。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> globalVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 仅在此文件内可见
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">helperFunction</span>() { <span style="color:#75715e">// 仅在此文件内可用
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 函数实现
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="3-类的静态成员">
  3. 类的静态成员
  <a class="heading-link" href="#3-%e7%b1%bb%e7%9a%84%e9%9d%99%e6%80%81%e6%88%90%e5%91%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在类定义中，<code>static</code>关键字用于声明静态成员变量和静态成员函数。静态成员属于整个类而不是类的任何特定对象，因此即使没有创建类的实例，也可以访问静态成员。所有实例共享同一静态成员数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVar; <span style="color:#75715e">// 静态成员变量
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">staticFunction</span>() { <span style="color:#75715e">// 静态成员函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Accessing static function.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span><span style="color:#66d9ef">int</span> MyClass<span style="color:#f92672">::</span>staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 静态成员变量的定义和初始化
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">example</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    MyClass<span style="color:#f92672">::</span>staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// 访问静态成员变量
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span><span style="color:#75715e"></span>    MyClass<span style="color:#f92672">::</span>staticFunction(); <span style="color:#75715e">// 调用静态成员函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="总结">
  总结
  <a class="heading-link" href="#%e6%80%bb%e7%bb%93">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>当<code>static</code>用于函数内的局部变量时，它延长了变量的生命周期。</li>
<li>当<code>static</code>用于文件范围内的全局变量或函数时，它限制了变量或函数的链接性，使其仅在定义它们的文件内可见。</li>
<li>在类的上下文中，<code>static</code>用于声明属于整个类而不是某个实例的成员，允许在没有类实例的情况下访问这些成员。</li>
</ul>
<p>这些特性使得<code>static</code>成为C++编程中一个非常有用和灵活的关键字。</p>
<h2 id="static-成员函数">
  Static 成员函数
  <a class="heading-link" href="#static-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，类的静态成员函数是属于整个类而不是类的任何特定对象的函数。静态成员函数与静态成员变量一样，它们不依赖于类的实例。这意味着即使没有创建类的对象，也可以调用静态成员函数。静态成员函数只能访问其类的静态成员变量和其他静态成员函数；它们不能直接访问类的非静态成员变量或函数，因为这些成员需要一个具体的类实例。</p>
<h3 id="特性">
  特性
  <a class="heading-link" href="#%e7%89%b9%e6%80%a7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>类级别的函数</strong>：静态成员函数作用于类级别而非实例级别。</li>
<li><strong>访问限制</strong>：只能直接访问静态成员变量和其他静态成员函数，不能直接访问非静态成员。</li>
<li><strong>调用方式</strong>：通过类名和作用域解析操作符<code>::</code>调用，而不是通过类的实例。</li>
</ul>
<h3 id="使用场景">
  使用场景
  <a class="heading-link" href="#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>工具函数</strong>：当需要一个与类相关但不需要类实例就能执行的功能时，静态成员函数很有用。例如，计算两个参数的最大值或最小值等。</li>
<li><strong>单例模式</strong>：在实现单例模式时，用于获取类的唯一实例的函数通常声明为静态的。</li>
<li><strong>访问静态成员变量</strong>：用于访问和修改静态成员变量的值，尤其是当这些变量被声明为私有时，提供公共的静态成员函数来获取和设置它们的值是一种常见的做法。</li>
</ul>
<h3 id="示例代码">
  示例代码
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> staticVar;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">staticFunction</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Accessing staticVar: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> staticVar <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nonStaticFunction</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>        <span style="color:#75715e">// 静态成员函数可以被非静态成员函数调用
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span><span style="color:#75715e"></span>        staticFunction();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span><span style="color:#75715e">// 静态成员变量的初始化
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> Example<span style="color:#f92672">::</span>staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span>    <span style="color:#75715e">// 通过类名调用静态成员函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span><span style="color:#75715e"></span>    Example<span style="color:#f92672">::</span>staticFunction(); <span style="color:#75715e">// 输出: Accessing staticVar: 10
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span><span>    <span style="color:#75715e">// 修改静态成员变量
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span><span><span style="color:#75715e"></span>    Example<span style="color:#f92672">::</span>staticVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span><span>    <span style="color:#75715e">// 再次调用静态成员函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span><span><span style="color:#75715e"></span>    Example<span style="color:#f92672">::</span>staticFunction(); <span style="color:#75715e">// 输出: Accessing staticVar: 20
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span><span>    <span style="color:#75715e">// 创建类实例并调用非静态成员函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span><span><span style="color:#75715e"></span>    Example example;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32</span><span>    example.nonStaticFunction(); <span style="color:#75715e">// 输出: Accessing staticVar: 20
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34</span><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35</span><span>}
</span></span></code></pre></div><p>在这个例子中，<code>staticFunction</code>是一个静态成员函数，它访问了同一个类的静态成员变量<code>staticVar</code>。即使没有<code>Example</code>类的实例，也可以通过<code>Example::staticFunction()</code>来调用这个函数。静态成员函数是类的一部分，而不是任何特定实例的一部分，因此它们在设计类时提供了一种灵活的工具，尤其是在实现只与类相关而不依赖于类实例的行为时。</p>
<h2 id="不同文件中的static变量的初始化顺序有规定吗">
  不同文件中的static变量的初始化顺序有规定吗
  <a class="heading-link" href="#%e4%b8%8d%e5%90%8c%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84static%e5%8f%98%e9%87%8f%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f%e6%9c%89%e8%a7%84%e5%ae%9a%e5%90%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，不同文件（编译单元）中的静态变量（也称为静态存储期变量，包括全局变量、文件作用域的静态变量以及类的静态成员变量）的初始化顺序涉及到两个主要概念：在单个编译单元内的初始化顺序和跨多个编译单元的初始化顺序。</p>
<h3 id="单个编译单元内的初始化顺序">
  单个编译单元内的初始化顺序
  <a class="heading-link" href="#%e5%8d%95%e4%b8%aa%e7%bc%96%e8%af%91%e5%8d%95%e5%85%83%e5%86%85%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在一个给定的编译单元（通常是一个源文件）内，静态变量按照它们出现的顺序被初始化。这意味着第一个声明的静态变量会先被初始化，以此类推。这部分是明确且可预测的。</p>
<h3 id="跨多个编译单元的初始化顺序">
  跨多个编译单元的初始化顺序
  <a class="heading-link" href="#%e8%b7%a8%e5%a4%9a%e4%b8%aa%e7%bc%96%e8%af%91%e5%8d%95%e5%85%83%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>跨多个编译单元（不同的源文件）的静态变量初始化顺序是未定义的。这意味着，如果你有两个源文件，每个文件中都定义了一个静态变量，那么你不能保证这两个变量哪一个会先被初始化。这种情况通常被称为“静态初始化顺序问题”或“静态初始化顺序地狱”。</p>
<h3 id="静态初始化顺序问题的解决办法">
  静态初始化顺序问题的解决办法
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f%e9%97%ae%e9%a2%98%e7%9a%84%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>为了解决或避免跨编译单元的静态初始化顺序问题，C++提供了一种被称为“构造函数初始化”（Construct On First Use）的技巧。它通过将静态变量封装在函数内部来延迟变量的初始化，直到这个变量被首次使用时才进行。这样做的好处是确保了初始化的顺序性和确定性。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#75715e">// 获取静态变量的函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#75715e"></span>SomeClass<span style="color:#f92672">&amp;</span> getStaticInstance() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>    <span style="color:#66d9ef">static</span> SomeClass instance; <span style="color:#75715e">// 首次调用此函数时初始化
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>}
</span></span></code></pre></div><p>在这个例子中，<code>instance</code>变量在<code>getStaticInstance()</code>函数首次被调用时初始化。这保证了无论变量在程序中被首次访问的时间点或顺序如何，<code>instance</code>的初始化都是安全和确定的。</p>
<h3 id="总结-1">
  总结
  <a class="heading-link" href="#%e6%80%bb%e7%bb%93-1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>虽然C++标准没有规定不同编译单元中静态变量的初始化顺序，但通过使用特定的设计模式和技巧，如“构造函数初始化”模式，可以有效地避免由此产生的问题。这种方法不仅可以解决初始化顺序问题，还可以延迟对象的初始化直到真正需要时，从而提高程序的启动性能和资源使用效率。</p>
<h2 id="c单例模式代码">
  C++单例模式代码
  <a class="heading-link" href="#c%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e4%bb%a3%e7%a0%81">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。在C++中实现单例模式通常涉及以下几个关键步骤：</p>
<ol>
<li>将构造函数、复制构造函数和赋值运算符标记为私有或删除，以防止外部创建类的多个实例。</li>
<li>在类内部提供一个静态私有指针变量，用于持有唯一的类实例。</li>
<li>提供一个公有的静态方法，用于获取这个唯一实例。</li>
</ol>
<p>下面是单例模式的一个基本实现示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>    <span style="color:#75715e">// 私有静态成员变量，指向唯一实例
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">*</span> instance;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>    <span style="color:#75715e">// 私有构造函数，防止外部直接创建实例
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span><span style="color:#75715e"></span>    Singleton() {}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>    <span style="color:#75715e">// 私有复制构造函数和赋值运算符，防止复制实例
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span><span style="color:#75715e"></span>    Singleton(<span style="color:#66d9ef">const</span> Singleton<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    Singleton<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Singleton<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>    <span style="color:#75715e">// 公有静态方法，用于获取唯一实例的引用
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">&amp;</span> getInstance() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>        <span style="color:#66d9ef">if</span> (instance <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>            instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Singleton();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>instance;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span><span>    <span style="color:#75715e">// 示例方法
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Doing something.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span><span><span style="color:#75715e">// 初始化静态成员变量
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span><span><span style="color:#75715e"></span>Singleton<span style="color:#f92672">*</span> Singleton<span style="color:#f92672">::</span>instance <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34</span><span>    <span style="color:#75715e">// 获取单例的引用并调用方法
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35</span><span><span style="color:#75715e"></span>    Singleton<span style="color:#f92672">::</span>getInstance().doSomething();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37</span><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38</span><span>}
</span></span></code></pre></div><p>这个例子展示了单例模式的核心要素：私有的构造函数和静态方法<code>getInstance()</code>确保全局只能通过该方法访问唯一的实例。通过将复制构造函数和赋值运算符设置为私有或删除，防止了实例的复制。</p>
<p>需要注意的是，这个基本实现在多线程环境下可能不是线程安全的。在多线程程序中，可能需要额外的同步机制（如互斥锁）来确保在创建单例实例时只有一个线程可以执行初始化代码。</p>
<p>对于多线程安全的单例实现，C++11及以后的版本提供了一个更简洁的方法，依靠局部静态变量的特性来保证线程安全：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>    <span style="color:#75715e">// 删除复制构造函数和赋值运算符
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#75715e"></span>    Singleton(<span style="color:#66d9ef">const</span> Singleton<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>    Singleton<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Singleton<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>    <span style="color:#75715e">// 提供一个静态方法获取单例引用
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">&amp;</span> getInstance() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>        <span style="color:#66d9ef">static</span> Singleton instance; <span style="color:#75715e">// 局部静态变量
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> instance;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Doing something.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>    <span style="color:#75715e">// 私有构造函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span><span style="color:#75715e"></span>    Singleton() {}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>};
</span></span></code></pre></div><p>在这个版本中，<code>instance</code>是一个局部静态变量，C++标准保证了当<code>getInstance()</code>第一次被调用时，<code>instance</code>将被创建，并且只会创建一次，即使在多线程环境下也能保证这一点。这种方法简化了代码，同时保证了线程安全性。</p>
<h2 id="静态变量和线程安全的关系">
  静态变量和线程安全的关系？
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e5%92%8c%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%85%b3%e7%b3%bb">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>静态变量和线程安全之间的关系是一个重要的考虑点，特别是在多线程程序设计中。理解这一关系有助于开发出安全且高效的并发应用。</p>
<h3 id="静态变量">
  静态变量
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>静态变量在程序的生命周期内只被初始化一次，并在后续的程序运行过程中保持其状态。在C++中，静态变量可以是全局静态变量、局部静态变量、或是类的静态成员变量。全局静态变量和类的静态成员变量在所有对象和函数调用中共享，而局部静态变量在其所在函数的所有调用中共享。</p>
<h3 id="线程安全">
  线程安全
  <a class="heading-link" href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>线程安全是指代码在多线程环境中被执行时，能够正确处理多个线程同时访问相同资源的情况，而不会导致数据损坏或不一致。如果一个函数或数据结构可以在多个线程中安全地被并发使用，不需要额外的同步机制，就称它为线程安全的。</p>
<h3 id="静态变量与线程安全">
  静态变量与线程安全
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e4%b8%8e%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>由于静态变量在多个线程中共享，如果多个线程试图同时修改同一个静态变量，就可能导致数据冲突和不一致的问题。因此，静态变量本身不是线程安全的，除非采取了适当的同步措施。</p>
<ul>
<li><strong>全局静态变量和类的静态成员变量</strong>：当多个线程访问和修改这些变量时，如果没有适当的锁机制（例如互斥锁）来控制访问，就可能导致数据竞争和不一致性问题。</li>
<li><strong>局部静态变量</strong>：在C++11及以后的版本中，局部静态变量的初始化是线程安全的，即在第一次访问变量时进行的初始化操作是由编译器自动加锁的，确保只有一个线程可以初始化变量。然而，初始化之后对变量的访问和修改仍然需要额外的同步措施来保证线程安全。</li>
</ul>
<h3 id="保证线程安全的策略">
  保证线程安全的策略
  <a class="heading-link" href="#%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e7%ad%96%e7%95%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>互斥锁</strong>：使用互斥锁（mutex）来同步对静态变量的访问。任何线程在访问变量之前必须首先获得锁，并在访问完成后释放锁。</li>
<li><strong>原子操作</strong>：对于简单的数据类型，可以使用原子操作来更新静态变量，原子操作保证了操作的不可分割性，从而避免了数据竞争。</li>
<li><strong>线程局部存储</strong>：如果静态变量不需要在多个线程间共享，可以考虑将其改为线程局部存储（Thread Local Storage, TLS），使得每个线程都有自己的变量副本。</li>
</ul>
<p>总之，虽然静态变量在多线程程序中提供了便利和效率，但正确管理对它们的访问至关重要，以确保程序的线程安全性和稳定性。在设计多线程程序时，应该仔细考虑如何同步对静态资源的访问，以避免潜在的竞争条件和其他线程安全问题。</p>
<h2 id="输入url到网页显示的过程">
  输入url到网页显示的过程
  <a class="heading-link" href="#%e8%be%93%e5%85%a5url%e5%88%b0%e7%bd%91%e9%a1%b5%e6%98%be%e7%a4%ba%e7%9a%84%e8%bf%87%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>当你在浏览器中输入一个URL并按下回车键后，发生了一系列复杂的过程，这些过程一起工作，将网页内容呈现到你的屏幕上。以下是这个过程的高级概述：</p>
<h3 id="1-解析url">
  1. 解析URL
  <a class="heading-link" href="#1-%e8%a7%a3%e6%9e%90url">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>**URL（统一资源定位符）**分析成不同的部分：协议（如HTTP或HTTPS）、服务器地址（域名）和资源路径。</li>
<li>浏览器会检查URL格式是否正确，如果URL不完整或有误，浏览器可能会尝试修正它或使用搜索引擎来寻找正确的地址。</li>
</ul>
<h3 id="2-域名解析dns查询">
  2. 域名解析（DNS查询）
  <a class="heading-link" href="#2-%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90dns%e6%9f%a5%e8%af%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>浏览器会查找URL中域名对应的IP地址。这通常涉及到DNS（域名系统）查询。</li>
<li>首先，浏览器检查本地缓存中是否有此域名的记录；如果没有，浏览器会向配置的DNS服务器发送查询请求。</li>
</ul>
<h3 id="3-建立连接">
  3. 建立连接
  <a class="heading-link" href="#3-%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>一旦获取到服务器的IP地址，浏览器会向服务器发起连接。对于HTTP协议，这意味着建立一个TCP连接；对于HTTPS协议，还需要进行TLS握手以建立一个加密连接。</li>
</ul>
<h3 id="4-发送http请求">
  4. 发送HTTP请求
  <a class="heading-link" href="#4-%e5%8f%91%e9%80%81http%e8%af%b7%e6%b1%82">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>浏览器构建一个HTTP请求，并通过TCP连接发送给服务器。这个请求包括请求行（如<code>GET /index.html HTTP/1.1</code>）、请求头（包括浏览器类型、接受的内容类型等）和请求体（对于某些类型的请求）。</li>
</ul>
<h3 id="5-服务器处理请求并响应">
  5. 服务器处理请求并响应
  <a class="heading-link" href="#5-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%a4%84%e7%90%86%e8%af%b7%e6%b1%82%e5%b9%b6%e5%93%8d%e5%ba%94">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>服务器接收到请求后，会根据请求类型处理请求（如查找请求的资源）。</li>
<li>服务器将响应发送回浏览器，响应通常包括一个状态码（如200表示成功），响应头（包含内容类型、编码等信息）和响应体（即请求的资源内容）。</li>
</ul>
<h3 id="6-浏览器渲染页面">
  6. 浏览器渲染页面
  <a class="heading-link" href="#6-%e6%b5%8f%e8%a7%88%e5%99%a8%e6%b8%b2%e6%9f%93%e9%a1%b5%e9%9d%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>浏览器接收到服务器的响应数据后，会根据响应的内容类型解析响应体。</li>
<li>如果是HTML文档，浏览器会解析HTML结构，构建DOM（文档对象模型）树。</li>
<li>浏览器解析CSS样式，并应用到DOM树上，构建渲染树。</li>
<li>执行JavaScript代码，可能会修改DOM树和渲染树。</li>
<li>浏览器布局渲染树中的元素，并将它们绘制到屏幕上，呈现最终的页面。</li>
</ul>
<h3 id="7-后续处理">
  7. 后续处理
  <a class="heading-link" href="#7-%e5%90%8e%e7%bb%ad%e5%a4%84%e7%90%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>如果页面中包含了需要进一步加载的资源（如图片、CSS文件、JavaScript文件等），浏览器会重复上述过程来获取这些资源，并更新页面内容。</li>
</ul>
<p>整个过程涉及网络、服务器、浏览器等多个层面的复杂交互。每一步都优化了速度和安全性，以确保用户能够快速、安全地获取和查看网页内容。</p>
<h2 id="什么时候会返回404">
  什么时候会返回404
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e8%bf%94%e5%9b%9e404">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>HTTP 404错误状态码表示服务器无法找到请求的资源。这种情况通常发生在以下几种场景中：</p>
<h3 id="1-url错误或拼写错误">
  1. URL错误或拼写错误
  <a class="heading-link" href="#1-url%e9%94%99%e8%af%af%e6%88%96%e6%8b%bc%e5%86%99%e9%94%99%e8%af%af">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>如果URL中的路径或文件名存在拼写错误，服务器会因为找不到匹配的资源而返回404错误。例如，如果用户尝试访问的网页路径拼写错误（如<code>/hom</code>代替<code>/home</code>），服务器将无法找到该资源。</p>
<h3 id="2-资源被移动或删除">
  2. 资源被移动或删除
  <a class="heading-link" href="#2-%e8%b5%84%e6%ba%90%e8%a2%ab%e7%a7%bb%e5%8a%a8%e6%88%96%e5%88%a0%e9%99%a4">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>如果之前存在的网页或资源被网站管理员移动到另一个位置，或者被完全删除，没有进行适当的重定向处理，那么对这个资源的请求将会返回404错误。这是导致404错误的常见原因。</p>
<h3 id="3-服务器配置问题">
  3. 服务器配置问题
  <a class="heading-link" href="#3-%e6%9c%8d%e5%8a%a1%e5%99%a8%e9%85%8d%e7%bd%ae%e9%97%ae%e9%a2%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>服务器配置错误也可能导致404错误。例如，如果Web服务器（如Apache或Nginx）的配置文件中指定的资源目录路径错误，或者配置了错误的重写规则，那么即使请求的资源存在，用户也可能收到404错误。</p>
<h3 id="4-域名解析错误">
  4. 域名解析错误
  <a class="heading-link" href="#4-%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90%e9%94%99%e8%af%af">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>尽管这种情况较少见，但如果域名未正确解析到正确的服务器，或者服务器上没有为该域名配置虚拟主机，那么请求可能会被发送到错误的服务器，从而可能返回404错误。</p>
<h3 id="5-链接过时">
  5. 链接过时
  <a class="heading-link" href="#5-%e9%93%be%e6%8e%a5%e8%bf%87%e6%97%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>对于一些内容管理系统（CMS）或动态生成的网站，页面的URL可能随着内容更新而改变。如果其他网站或用户的书签链接到了旧的URL，这将导致404错误。</p>
<h3 id="6-权限问题">
  6. 权限问题
  <a class="heading-link" href="#6-%e6%9d%83%e9%99%90%e9%97%ae%e9%a2%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在某些情况下，服务器可能配置为对未授权访问某些资源返回404错误，而不是403错误（禁止访问），这是为了隐藏资源的存在，增加安全性。</p>
<h3 id="应对404错误的措施">
  应对404错误的措施
  <a class="heading-link" href="#%e5%ba%94%e5%af%b9404%e9%94%99%e8%af%af%e7%9a%84%e6%8e%aa%e6%96%bd">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>检查URL</strong>：确认URL输入正确，没有拼写错误。</li>
<li><strong>使用搜索功能</strong>：如果网站提供搜索功能，可以尝试搜索想要找到的内容。</li>
<li><strong>检查网站的站点地图</strong>：站点地图列出了网站上所有可访问的页面链接。</li>
<li><strong>联系网站管理员</strong>：如果认为页面应该存在，可以尝试联系网站的管理员或支持团队获取帮助。</li>
<li><strong>设置自定义404页面</strong>：对于网站开发者来说，设置一个友好的404错误页面可以提供返回主页的链接或者搜索框，帮助用户找到他们感兴趣的内容。</li>
</ul>
<p>404错误虽然令人沮丧，但正确处理这些错误可以提升用户体验，并帮助访问者找到他们感兴趣的内容或返回网站的其它部分。</p>
<h2 id="tcp怎么实现可靠传输">
  TCP怎么实现可靠传输
  <a class="heading-link" href="#tcp%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>TCP（传输控制协议）通过一系列的机制来实现在不可靠的网络层之上的可靠数据传输。这些机制确保了数据正确、有序地传输，即使在网络条件不佳的情况下也能尽可能保证数据的完整性和顺序。以下是TCP实现可靠传输的主要机制：</p>
<h3 id="1-三次握手建立连接">
  1. 三次握手建立连接
  <a class="heading-link" href="#1-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>TCP使用一种称为“三次握手”的过程来建立连接，以确保双方都准备好进行数据传输。这个过程也同步双方的序列号，以便于后续的数据传输可以被正确排序，并跟踪哪些数据已被成功接收。</p>
<h3 id="2-数据包排序">
  2. 数据包排序
  <a class="heading-link" href="#2-%e6%95%b0%e6%8d%ae%e5%8c%85%e6%8e%92%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>每个TCP段都包含一个序列号，这允许接收方对接收到的数据包进行排序，以确保数据的正确顺序。</p>
<h3 id="3-确认应答与超时重传">
  3. 确认应答与超时重传
  <a class="heading-link" href="#3-%e7%a1%ae%e8%ae%a4%e5%ba%94%e7%ad%94%e4%b8%8e%e8%b6%85%e6%97%b6%e9%87%8d%e4%bc%a0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>接收方对收到的TCP段发送确认（ACK）回复，表明它已成功接收到该段。如果发送方在一个预定的超时期限内没有收到确认，它将重新发送该数据段。这个机制确保了数据的成功传输。</p>
<h3 id="4-流量控制">
  4. 流量控制
  <a class="heading-link" href="#4-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>TCP使用窗口大小来进行流量控制，这个窗口大小告诉发送方接收方还能接收多少数据。这避免了发送方发送太多数据，导致接收方处理不过来而丢失数据。</p>
<h3 id="5-拥塞控制">
  5. 拥塞控制
  <a class="heading-link" href="#5-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>TCP实现了几种拥塞控制算法（如慢启动、拥塞避免、快重传和快恢复）来减少网络中的拥塞。这些算法调整数据的传输速率，以响应网络中的拥塞情况，避免过多的数据包同时传输导致的网络拥塞和数据包丢失。</p>
<h3 id="6-保活机制">
  6. 保活机制
  <a class="heading-link" href="#6-%e4%bf%9d%e6%b4%bb%e6%9c%ba%e5%88%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>TCP保活机制可以检测出空闲的连接，防止连接由于长时间的无活动而被意外关闭。通过定期发送保活探针，TCP可以判断对方是否仍然可达。</p>
<h3 id="7-四次挥手断开连接">
  7. 四次挥手断开连接
  <a class="heading-link" href="#7-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>TCP使用四次挥手的过程来安全地关闭连接。这个过程确保了双方都已经发送和接收了所有的数据。</p>
<p>通过上述机制，TCP能够提供一种可靠的数据传输服务，即使在网络状况不稳定的情况下也能尽可能保证数据的完整性和顺序。这些特性使得TCP成为许多需要可靠数据传输的应用（如Web浏览、电子邮件和文件传输）的理想选择。</p>
<h2 id="tcp连接过多怎么办">
  TCP连接过多怎么办
  <a class="heading-link" href="#tcp%e8%bf%9e%e6%8e%a5%e8%bf%87%e5%a4%9a%e6%80%8e%e4%b9%88%e5%8a%9e">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>当TCP连接过多时，可能会导致服务器资源紧张，性能下降，甚至服务不可用。处理这种情况需要综合考虑，采取多种策略来优化和管理TCP连接。以下是一些常见的处理方法：</p>
<h3 id="1-优化服务器配置">
  1. 优化服务器配置
  <a class="heading-link" href="#1-%e4%bc%98%e5%8c%96%e6%9c%8d%e5%8a%a1%e5%99%a8%e9%85%8d%e7%bd%ae">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>增加最大连接数</strong>：调整操作系统和服务器软件的配置，增加可以同时打开的最大连接数。</li>
<li><strong>调整TCP参数</strong>：比如调整TCP Keepalive时间，减少TIME_WAIT状态持续的时间，以便更快地回收和重用端口。</li>
</ul>
<h3 id="2-使用负载均衡">
  2. 使用负载均衡
  <a class="heading-link" href="#2-%e4%bd%bf%e7%94%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>部署负载均衡器</strong>：在服务器前端部署负载均衡器，将流量分发到后端的多个服务器上。这样可以分散压力，提高整体的处理能力和可用性。</li>
</ul>
<h3 id="3-采用更高效的架构">
  3. 采用更高效的架构
  <a class="heading-link" href="#3-%e9%87%87%e7%94%a8%e6%9b%b4%e9%ab%98%e6%95%88%e7%9a%84%e6%9e%b6%e6%9e%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>使用异步IO</strong>：传统的同步IO模型在处理大量并发连接时可能会遇到瓶颈。采用异步IO模型（如IO多路复用）可以更高效地处理大量并发连接。</li>
<li><strong>事件驱动架构</strong>：事件驱动的服务器架构（如Node.js）能够更好地支持高并发连接，提高资源利用率。</li>
</ul>
<h3 id="4-优化应用层">
  4. 优化应用层
  <a class="heading-link" href="#4-%e4%bc%98%e5%8c%96%e5%ba%94%e7%94%a8%e5%b1%82">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>连接复用</strong>：在应用层面，尽量复用已建立的TCP连接（如HTTP Keep-Alive），减少频繁建立和断开连接的开销。</li>
<li><strong>限制连接时间</strong>：对于某些不需要长时间保持连接的应用，可以设定超时时间，超过时间限制后自动关闭连接。</li>
</ul>
<h3 id="5-资源监控和自动扩展">
  5. 资源监控和自动扩展
  <a class="heading-link" href="#5-%e8%b5%84%e6%ba%90%e7%9b%91%e6%8e%a7%e5%92%8c%e8%87%aa%e5%8a%a8%e6%89%a9%e5%b1%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>监控资源使用</strong>：持续监控服务器的CPU、内存、网络等资源使用情况，及时发现瓶颈。</li>
<li><strong>自动扩展</strong>：在云环境中，可以设置自动扩展策略，根据负载情况自动增减服务器实例。</li>
</ul>
<h3 id="6-防御拒绝服务攻击">
  6. 防御拒绝服务攻击
  <a class="heading-link" href="#6-%e9%98%b2%e5%be%a1%e6%8b%92%e7%bb%9d%e6%9c%8d%e5%8a%a1%e6%94%bb%e5%87%bb">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>如果TCP连接过多是由拒绝服务攻击（DoS/DDoS攻击）引起的，需要采取相应的防御措施，如部署专业的DDoS防御系统，限制IP连接速率等。</li>
</ul>
<p>处理TCP连接过多的问题需要从系统、网络和应用多个层面进行综合考虑和优化。在设计系统时，考虑到高并发和高可用性的需求，并采取适当的架构和技术来应对可能的高负载情况，是避免此类问题的关键。</p>
<h2 id="为什么有ip地址还有mac地址">
  为什么有IP地址还有MAC地址
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89ip%e5%9c%b0%e5%9d%80%e8%bf%98%e6%9c%89mac%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>IP地址和MAC地址都是网络中设备通信的重要组成部分，但它们在网络通信中扮演着不同的角色，服务于不同的网络层。理解它们之间的区别和为什么两者都需要，可以帮助我们更好地理解网络是如何工作的。</p>
<h3 id="ip地址">
  IP地址
  <a class="heading-link" href="#ip%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>IP地址（Internet Protocol Address）是网络层（特别是在TCP/IP模型中的第三层）的一个标识符，用于标识网络上的每个设备，以及帮助路由数据包从源头到目的地。IP地址主要用于不同网络或网络段之间的通信。因为网络设备可能频繁改变位置，进入不同的网络环境，IP地址可能会改变，特别是在使用DHCP服务时。</p>
<p>IP地址的主要功能包括：</p>
<ul>
<li><strong>标识</strong>：为每个连接到网络的设备提供唯一标识。</li>
<li><strong>路由</strong>：帮助网络中的路由器决定如何将数据包从源地址转发到目的地址。</li>
</ul>
<h3 id="mac地址">
  MAC地址
  <a class="heading-link" href="#mac%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>MAC地址（Media Access Control Address），也称为物理地址，是数据链路层（在TCP/IP模型中的第二层）的一个标识符，嵌入到网络接口卡（NIC）硬件中。MAC地址是在设备制造过程中分配的，通常是不变的（尽管可以通过软件进行修改）。MAC地址主要用于同一个物理网络内的设备之间的通信。</p>
<p>MAC地址的主要功能包括：</p>
<ul>
<li><strong>物理地址标识</strong>：为网络上每个物理设备提供唯一标识。</li>
<li><strong>局域网通信</strong>：在局域网（LAN）内部，数据包的传输是基于MAC地址的。设备使用MAC地址来确定数据包是否是发往自己的。</li>
</ul>
<h3 id="为什么两者都需要">
  为什么两者都需要
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%a4%e8%80%85%e9%83%bd%e9%9c%80%e8%a6%81">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>不同的网络层</strong>：IP地址和MAC地址分别服务于TCP/IP模型的不同层次。IP地址用于网络层，实现跨网络的数据传输。而MAC地址用于数据链路层，实现同一局域网内的设备通信。</li>
<li><strong>不同的功能和作用范围</strong>：IP地址提供逻辑地址，使得设备可以在全球范围内通信，而MAC地址提供物理地址，用于局域网内部的通信。</li>
<li><strong>路由和交换</strong>：在数据包传输过程中，路由器利用IP地址来路由数据包到正确的目的网络，而交换机则使用MAC地址来将数据包转发到正确的设备。</li>
</ul>
<p>综上所述，IP地址和MAC地址共同确保了数据能够在复杂的网络环境中，从源设备准确、高效地传输到目标设备。</p>
<h2 id="路由器有ip地址吗">
  路由器有IP地址吗
  <a class="heading-link" href="#%e8%b7%af%e7%94%b1%e5%99%a8%e6%9c%89ip%e5%9c%b0%e5%9d%80%e5%90%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>是的，路由器具有IP地址。实际上，路由器通常会有至少两个IP地址：一个是用于局域网（LAN）侧的内部网络接口的IP地址，另一个是用于广域网（WAN）侧的外部网络接口的IP地址。这些IP地址使路由器能够在不同的网络环境中正确地路由数据包。</p>
<h3 id="局域网lan侧ip地址">
  局域网（LAN）侧IP地址
  <a class="heading-link" href="#%e5%b1%80%e5%9f%9f%e7%bd%91lan%e4%be%a7ip%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>私有IP地址</strong>：路由器的LAN侧IP地址通常是一个私有IP地址，这个地址是路由器内部网络的默认网关地址。设备在发送数据到局域网外部的互联网时，数据包会被发送到这个地址。</li>
<li><strong>网关地址</strong>：在家庭或小型办公室网络中，路由器的LAN侧IP地址通常被配置为192.168.x.1或10.0.x.1这样的地址（x是0到255之间的任意数字），它作为内部网络中所有设备的默认网关。</li>
</ul>
<h3 id="广域网wan侧ip地址">
  广域网（WAN）侧IP地址
  <a class="heading-link" href="#%e5%b9%bf%e5%9f%9f%e7%bd%91wan%e4%be%a7ip%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>公有IP地址</strong>：路由器的WAN侧IP地址通常是由互联网服务提供商（ISP）分配的一个公有IP地址。这个地址是路由器在互联网上的标识，允许局域网内的设备通过路由器访问互联网。</li>
<li><strong>唯一性</strong>：为了能在互联网上被其他系统识别和访问，每个连接到互联网的设备必须有一个唯一的公有IP地址。由于公有IP地址是有限的，家庭和小型办公网络通常只有路由器拥有一个公有IP地址，而内部设备则使用NAT（网络地址转换）技术通过这个公有IP地址共享互联网连接。</li>
</ul>
<h3 id="管理ip地址">
  管理IP地址
  <a class="heading-link" href="#%e7%ae%a1%e7%90%86ip%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>用于管理的IP地址</strong>：除了用于路由的IP地址外，路由器还可能配置有一个特别的管理IP地址，用于访问路由器的管理界面（如Web界面）。这通常是路由器LAN侧的IP地址。</li>
</ul>
<p>总之，路由器拥有IP地址是它完成数据包路由、网络通信和管理任务的基础。通过这些IP地址，路由器能够在局域网内提供连接到互联网的通道，同时允许网络管理员对其进行配置和管理。</p>
<h2 id="内存泄露怎么解决">
  内存泄露怎么解决
  <a class="heading-link" href="#%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>内存泄露是指程序中已分配的内存未能成功释放，导致无法再被程序利用的情况。长时间运行或多次执行这样的程序可能会导致可用内存逐渐减少，最终影响程序性能或导致程序崩溃。解决内存泄露的问题通常需要几个步骤，包括检测、定位和修复泄露。</p>
<h3 id="检测内存泄露">
  检测内存泄露
  <a class="heading-link" href="#%e6%a3%80%e6%b5%8b%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>使用内存分析工具</strong>：大多数编程语言都提供了内存分析工具或库，如Valgrind、LeakSanitizer、Visual Studio的诊断工具、Xcode的Instruments等，可用于检测内存泄露。</p>
</li>
<li>
<p><strong>代码审查</strong>：定期进行代码审查，特别关注内存分配和释放的逻辑，可以帮助识别潜在的内存泄露问题。</p>
</li>
<li>
<p><strong>监控系统性能</strong>：通过监控应用程序的内存使用情况，可以发现异常的内存增长模式，这可能是内存泄露的迹象。</p>
</li>
</ol>
<h3 id="定位内存泄露">
  定位内存泄露
  <a class="heading-link" href="#%e5%ae%9a%e4%bd%8d%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>分析内存分配</strong>：利用内存分析工具，可以获取内存分配和释放的详细报告，从而定位未被释放的内存块。</p>
</li>
<li>
<p><strong>日志和调试信息</strong>：在关键的内存分配和释放点添加日志信息，可以帮助追踪内存使用情况，进而定位泄露的位置。</p>
</li>
<li>
<p><strong>代码分析</strong>：静态代码分析工具可以帮助识别内存管理的常见问题，例如未匹配的内存分配和释放。</p>
</li>
</ol>
<h3 id="修复内存泄露">
  修复内存泄露
  <a class="heading-link" href="#%e4%bf%ae%e5%a4%8d%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>确保匹配的内存释放</strong>：每次内存分配（例如<code>new</code>、<code>malloc</code>）都应该有对应的释放操作（例如<code>delete</code>、<code>free</code>）。</p>
</li>
<li>
<p><strong>使用智能指针（C++）</strong>：在C++中，使用智能指针（如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>）可以自动管理内存，减少显式释放内存的需要。</p>
</li>
<li>
<p><strong>利用RAII原则（资源获取即初始化）</strong>：确保资源（包括内存）的分配和释放都在同一个对象的构造函数和析构函数中进行，利用作用域自动管理资源。</p>
</li>
<li>
<p><strong>避免内存泄露的编程模式</strong>：例如，在C++中避免循环引用（可通过<code>std::weak_ptr</code>解决），在Java或C#中注意事件处理器的注册和注销等。</p>
</li>
<li>
<p><strong>内存池</strong>：对于频繁分配和释放的小对象，使用内存池可以减少内存碎片和泄露的可能性。</p>
</li>
</ol>
<p>解决内存泄露的关键在于深入理解代码的内存使用情况，以及利用合适的工具和策略来监控、定位和修复问题。持续的性能监控、代码审查和测试是防止内存泄露的重要手段。</p>
<h2 id="为什么要有虚拟内存空间">
  为什么要有虚拟内存空间
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>虚拟内存空间是现代计算机系统中的一个关键概念，它提供了一个抽象层，使得软件开发者和操作系统能够更有效地管理硬件资源。虚拟内存的引入主要基于以下几个原因和优势：</p>
<h3 id="1-内存扩展">
  1. 内存扩展
  <a class="heading-link" href="#1-%e5%86%85%e5%ad%98%e6%89%a9%e5%b1%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>扩大可用内存</strong>：虚拟内存允许系统使用硬盘空间作为额外的内存，从而扩大了可供程序使用的内存空间。这意味着即使物理RAM不足，程序也能运行，因为操作系统可以将部分数据暂时存储在硬盘的虚拟内存页中。</li>
</ul>
<h3 id="2-进程隔离">
  2. 进程隔离
  <a class="heading-link" href="#2-%e8%bf%9b%e7%a8%8b%e9%9a%94%e7%a6%bb">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>提供进程间隔离</strong>：每个进程都在其自己的虚拟地址空间中运行，这使得进程之间的内存访问相互隔离，防止一个进程的错误操作（如越界访问）影响到其他进程。</li>
</ul>
<h3 id="3-内存管理简化">
  3. 内存管理简化
  <a class="heading-link" href="#3-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%ae%80%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>简化内存管理</strong>：虚拟内存使得操作系统可以为每个进程提供一致的地址空间，简化了内存的分配和管理。程序员无需担心物理内存的具体位置和限制，可以认为有一个几乎无限大的内存空间。</li>
</ul>
<h3 id="4-内存保护">
  4. 内存保护
  <a class="heading-link" href="#4-%e5%86%85%e5%ad%98%e4%bf%9d%e6%8a%a4">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>增强安全性和稳定性</strong>：操作系统可以通过虚拟内存来控制每个进程对内存的访问权限（如只读、读写或执行权限），增加了系统的安全性和稳定性。</li>
</ul>
<h3 id="5-数据共享">
  5. 数据共享
  <a class="heading-link" href="#5-%e6%95%b0%e6%8d%ae%e5%85%b1%e4%ba%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>方便数据共享与通信</strong>：虚拟内存机制也使得不同进程间共享内存成为可能，便于进程间的数据共享和通信。</li>
</ul>
<h3 id="6-物理内存优化">
  6. 物理内存优化
  <a class="heading-link" href="#6-%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%bc%98%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>优化物理内存使用</strong>：虚拟内存允许操作系统更灵活地管理物理内存，如通过页面置换算法（如最近最少使用LRU算法）来决定哪些数据应当保留在RAM中，哪些可以被移动到硬盘，从而最优化物理内存的使用。</li>
</ul>
<h3 id="7-支持多任务">
  7. 支持多任务
  <a class="heading-link" href="#7-%e6%94%af%e6%8c%81%e5%a4%9a%e4%bb%bb%e5%8a%a1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>支持多任务处理</strong>：虚拟内存为多任务操作系统提供了基础，使得多个应用程序能够同时运行，同时保证它们的运行环境互不干扰，提高了计算机系统的效率和响应速度。</li>
</ul>
<p>虚拟内存通过上述优势，不仅提高了计算机的性能和资源利用率，也极大地简化了程序设计和系统管理，是现代操作系统不可或缺的一部分。</p>
<h2 id="i是原子性的吗">
  i++是原子性的吗
  <a class="heading-link" href="#i%e6%98%af%e5%8e%9f%e5%ad%90%e6%80%a7%e7%9a%84%e5%90%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>i++</code>操作（自增操作）在多数编程语言中并不是原子性的，尽管在单个线程的上下文中这个操作看起来只是简单地增加变量的值。<code>i++</code>实际上包含了三个独立的步骤：读取变量<code>i</code>的当前值、增加这个值、将新值写回到变量<code>i</code>。在多线程环境中，如果没有适当的同步机制，这三个步骤之间可能会被其他线程的操作打断，导致竞态条件和数据不一致的问题。</p>
<h3 id="为什么i不是原子性的">
  为什么<code>i++</code>不是原子性的
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88i%e4%b8%8d%e6%98%af%e5%8e%9f%e5%ad%90%e6%80%a7%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li><strong>读取</strong>：首先，程序需要读取变量<code>i</code>的当前值到CPU寄存器。</li>
<li><strong>修改</strong>：在CPU寄存器中，给这个值加1。</li>
<li><strong>写回</strong>：最后，将新值写回内存中的变量<code>i</code>。</li>
</ol>
<p>这个过程中的任何步骤都可能被其他线程打断，特别是在没有锁或其他同步机制保护的情况下。例如，两个线程几乎同时读取<code>i</code>的值，然后分别增加1并尝试写回，结果是<code>i</code>实际上只增加了1而不是2。</p>
<h3 id="如何确保操作的原子性">
  如何确保操作的原子性
  <a class="heading-link" href="#%e5%a6%82%e4%bd%95%e7%a1%ae%e4%bf%9d%e6%93%8d%e4%bd%9c%e7%9a%84%e5%8e%9f%e5%ad%90%e6%80%a7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>要确保类似<code>i++</code>这样的操作在多线程环境中的原子性，可以采用以下一种或多种方法：</p>
<ul>
<li><strong>使用互斥锁（Mutex）</strong>：通过在执行<code>i++</code>操作之前获取互斥锁，然后执行操作，最后释放锁，可以确保这个操作在完成之前不会被其他线程打断。</li>
<li><strong>原子操作函数</strong>：许多编程语言和库提供了原子操作API，比如C++11引入的<code>std::atomic</code>类型和相关操作，或Java的<code>java.util.concurrent.atomic</code>包中的类。这些API能够保证变量操作的原子性。</li>
<li><strong>使用硬件同步原语</strong>：某些平台提供了CPU指令级的支持来执行原子操作，如x86架构的CMPXCHG指令。编程语言或库的原子操作API底层可能会利用这些硬件特性。</li>
</ul>
<p>总之，<code>i++</code>操作本身在多线程环境下不是原子性的，需要通过同步机制或使用特定的原子操作API来保证其安全性。在设计多线程程序时，正确处理这类操作至关重要，以避免数据不一致和竞态条件。</p>
<h2 id="子类中变量初始化顺序和销毁顺序">
  子类中变量初始化顺序和销毁顺序
  <a class="heading-link" href="#%e5%ad%90%e7%b1%bb%e4%b8%ad%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f%e5%92%8c%e9%94%80%e6%af%81%e9%a1%ba%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在面向对象的编程中，特别是在使用如Java、C++等语言时，子类和父类中变量的初始化和销毁顺序遵循特定的规则，这些规则保证了对象的构造和析构过程的正确性和逻辑性。下面是这些语言中常见的初始化和销毁顺序的概述：</p>
<h3 id="java">
  Java
  <a class="heading-link" href="#java">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="初始化顺序">
  初始化顺序
  <a class="heading-link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ol>
<li><strong>父类静态变量和静态初始化块</strong>：按照它们在父类中出现的顺序。</li>
<li><strong>子类静态变量和静态初始化块</strong>：按照它们在子类中出现的顺序。</li>
<li><strong>父类非静态变量和非静态初始化块</strong>：按照它们在父类中出现的顺序。</li>
<li><strong>父类构造器</strong>。</li>
<li><strong>子类非静态变量和非静态初始化块</strong>：按照它们在子类中出现的顺序。</li>
<li><strong>子类构造器</strong>。</li>
</ol>
<h4 id="销毁顺序">
  销毁顺序
  <a class="heading-link" href="#%e9%94%80%e6%af%81%e9%a1%ba%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Java中，对象的销毁是由垃圾回收器(GC)处理的，没有像C++中析构函数那样直接的销毁过程。但是，可以通过<code>finalize()</code>方法提供一定的清理逻辑。通常，<code>finalize()</code>方法的调用顺序与构造器的调用顺序相反，但依赖于GC的具体实现和行为，<code>finalize()</code>方法的调用时机和顺序可能是不确定的。</p>
<h3 id="c">
  C++
  <a class="heading-link" href="#c">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="初始化顺序-1">
  初始化顺序
  <a class="heading-link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f-1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<ol>
<li><strong>父类构造器</strong>：首先调用基类的构造函数。</li>
<li><strong>成员变量初始化</strong>：按照它们声明的顺序初始化父类的成员变量。</li>
<li><strong>父类构造器体内的代码</strong>。</li>
<li><strong>成员变量初始化</strong>：按照它们声明的顺序初始化子类的成员变量。</li>
<li><strong>子类构造器体内的代码</strong>。</li>
</ol>
<h4 id="销毁顺序-1">
  销毁顺序
  <a class="heading-link" href="#%e9%94%80%e6%af%81%e9%a1%ba%e5%ba%8f-1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>销毁顺序与初始化顺序相反：</p>
<ol>
<li><strong>子类析构器体内的代码</strong>。</li>
<li><strong>子类成员变量的析构</strong>：按照初始化顺序的逆序进行销毁。</li>
<li><strong>父类析构器体内的代码</strong>。</li>
<li><strong>父类成员变量的析构</strong>：按照初始化顺序的逆序进行销毁。</li>
</ol>
<p>在C++中，析构函数是显式定义的，它们提供了在对象销毁时执行清理资源等操作的机会。与Java不同，C++的对象销毁是确定的，由程序员或对象作用域结束时自动触发。</p>
<p>这些初始化和销毁的规则确保了对象在其生命周期内的状态和行为的正确性，是面向对象编程中重要的概念。理解这些规则对于编写可靠和高效的代码至关重要。</p>
<h2 id="cpu如何实现除法">
  cpu如何实现除法
  <a class="heading-link" href="#cpu%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e9%99%a4%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>CPU实现除法的方法可以根据其设计和指令集架构的不同而不同。在硬件层面，有几种常见的方法用于实现除法运算：</p>
<h3 id="1-长除法硬件实现">
  1. 长除法（硬件实现）
  <a class="heading-link" href="#1-%e9%95%bf%e9%99%a4%e6%b3%95%e7%a1%ac%e4%bb%b6%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>这是最直观的方法，类似于我们在纸上执行的长除法过程，但是在二进制下进行。CPU通过一系列的移位、比较和减法操作来实现除法。这个过程涉及将被除数左移（相当于在二进制下的乘以2），然后与除数比较，如果被除数大于等于除数，就从被除数中减去除数，并在商的相应位置上放置一个1，否则放置一个0。这个过程重复进行，直到完成所有的位操作。</p>
<h3 id="2-逼近法硬件实现">
  2. 逼近法（硬件实现）
  <a class="heading-link" href="#2-%e9%80%bc%e8%bf%91%e6%b3%95%e7%a1%ac%e4%bb%b6%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>
<p><strong>牛顿-拉弗森迭代法（Newton-Raphson）</strong>：这种方法利用迭代逼近来找到除法的结果。它基于牛顿迭代法求解函数零点的数学原理，通过迭代计算逐步逼近真实的除法结果。这种方法特别适用于浮点除法。</p>
</li>
<li>
<p><strong>高德（Goldschmidt）迭代法</strong>：这是另一种迭代逼近方法，通过同时对被除数和除数进行乘法操作来逼近结果，最终将除法问题转化为乘法问题。</p>
</li>
</ul>
<h3 id="3-查表法软件硬件辅助实现">
  3. 查表法（软件/硬件辅助实现）
  <a class="heading-link" href="#3-%e6%9f%a5%e8%a1%a8%e6%b3%95%e8%bd%af%e4%bb%b6%e7%a1%ac%e4%bb%b6%e8%be%85%e5%8a%a9%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>对于一些特定的除数，可以通过查找预先计算好的除法结果表来快速得到结果。这种方法在执行小范围内的除法操作时效率很高，但对于大数的除法则不太实用，因为查表需要大量的存储空间。</p>
<h3 id="4-软件实现">
  4. 软件实现
  <a class="heading-link" href="#4-%e8%bd%af%e4%bb%b6%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>对于一些没有硬件除法支持的简单CPU或者特定应用场景，除法运算可能通过软件实现，即编译器将除法操作转换为一系列的基本操作，如移位、加法和减法。这种方法比直接的硬件支持要慢，但可以在不支持硬件除法的CPU上执行除法运算。</p>
<h3 id="性能考虑">
  性能考虑
  <a class="heading-link" href="#%e6%80%a7%e8%83%bd%e8%80%83%e8%99%91">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在CPU中，除法是相对较慢的操作，特别是浮点除法。因此，现代CPU设计采用高级算法和技术（如流水线处理、并行执行等）来优化除法操作的性能。在软件开发中，避免不必要的除法运算或将其替换为更快的操作（如移位）是常见的性能优化手段。</p>
<p>总的来说，CPU中除法的实现是复杂的，涉及多种算法和技术，旨在平衡计算的准确性和执行的效率。</p>
<h2 id="三个线程如何交替打印abc循环100次用c实现">
  三个线程如何交替打印ABC循环100次，用C++实现
  <a class="heading-link" href="#%e4%b8%89%e4%b8%aa%e7%ba%bf%e7%a8%8b%e5%a6%82%e4%bd%95%e4%ba%a4%e6%9b%bf%e6%89%93%e5%8d%b0abc%e5%be%aa%e7%8e%af100%e6%ac%a1%e7%94%a8c%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>实现三个线程交替打印ABC循环100次的任务，可以通过同步机制来控制线程间的执行顺序。在C++中，可以使用<code>std::mutex</code>和<code>std::condition_variable</code>来实现这一目标。下面是一个具体的实现示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;condition_variable&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ABCPrinter</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>    ABCPrinter(<span style="color:#66d9ef">int</span> count) <span style="color:#f92672">:</span> count_(count) {}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printA</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count_; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>            std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(m_);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>            cv_.wait(lock, [<span style="color:#66d9ef">this</span>]() { <span style="color:#66d9ef">return</span> currentChar_ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;A&#39;</span>; });
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>            currentChar_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>            cv_.notify_all();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printB</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count_; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span>            std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(m_);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span>            cv_.wait(lock, [<span style="color:#66d9ef">this</span>]() { <span style="color:#66d9ef">return</span> currentChar_ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;B&#39;</span>; });
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;B&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span><span>            currentChar_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;C&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span><span>            cv_.notify_all();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printC</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count_; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32</span><span>            std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(m_);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33</span><span>            cv_.wait(lock, [<span style="color:#66d9ef">this</span>]() { <span style="color:#66d9ef">return</span> currentChar_ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;C&#39;</span>; });
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34</span><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;C&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35</span><span>            currentChar_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36</span><span>            cv_.notify_all();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40</span><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41</span><span>    std<span style="color:#f92672">::</span>mutex m_;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42</span><span>    std<span style="color:#f92672">::</span>condition_variable cv_;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43</span><span>    <span style="color:#66d9ef">char</span> currentChar_ <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44</span><span>    <span style="color:#66d9ef">int</span> count_;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">47</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">48</span><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">49</span><span>    ABCPrinter printer(count);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">50</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">51</span><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(<span style="color:#f92672">&amp;</span>ABCPrinter<span style="color:#f92672">::</span>printA, <span style="color:#f92672">&amp;</span>printer);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">52</span><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(<span style="color:#f92672">&amp;</span>ABCPrinter<span style="color:#f92672">::</span>printB, <span style="color:#f92672">&amp;</span>printer);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">53</span><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t3(<span style="color:#f92672">&amp;</span>ABCPrinter<span style="color:#f92672">::</span>printC, <span style="color:#f92672">&amp;</span>printer);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">54</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">55</span><span>    t1.join();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">56</span><span>    t2.join();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">57</span><span>    t3.join();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">58</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">59</span><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">60</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">61</span><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">62</span><span>}
</span></span></code></pre></div><p>这个程序中，<code>ABCPrinter</code>类控制着打印行为。类中有一个<code>std::mutex</code>用于同步，一个<code>std::condition_variable</code>用于线程间的条件等待和通知，以及一个<code>currentChar_</code>变量来标记当前应该打印哪个字符。</p>
<ul>
<li>每个打印函数（<code>printA</code>、<code>printB</code>、<code>printC</code>）都会尝试获得锁，并通过条件变量等待直到它们各自负责的字符（<code>currentChar_</code>）是当前应该打印的字符。</li>
<li>当条件满足时，打印相应的字符，并更新<code>currentChar_</code>为下一个字符，然后通过<code>cv_.notify_all()</code>唤醒所有等待的线程，这些线程再次检查条件是否满足自己打印的条件。</li>
<li>这个循环持续进行，直到打印了指定的次数。</li>
</ul>
<p>通过这种方式，三个线程可以协同工作，依次交替打印ABC，共计100次。</p>
<h2 id="unique_lock是什么">
  unique_lock是什么
  <a class="heading-link" href="#unique_lock%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>std::unique_lock</code>是C++标准库中的一个实用工具，提供了一种灵活的方式来管理带有互斥锁（<code>std::mutex</code>）的锁定和解锁操作。它是头文件<code>&lt;mutex&gt;</code>的一部分，是对基本互斥锁管理的一个封装，提供了比<code>std::lock_guard</code>更多的功能和灵活性。尽管<code>std::unique_lock</code>比<code>std::lock_guard</code>占用的资源稍多，但它在需要更复杂锁管理的场景下非常有用。</p>
<h3 id="主要特点和用途">
  主要特点和用途
  <a class="heading-link" href="#%e4%b8%bb%e8%a6%81%e7%89%b9%e7%82%b9%e5%92%8c%e7%94%a8%e9%80%94">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>灵活的锁管理</strong>：<code>std::unique_lock</code>允许在运行时进行锁的获取和释放，而<code>std::lock_guard</code>仅在构造时加锁，在析构时解锁，不提供中途手动控制锁的功能。</p>
</li>
<li>
<p><strong>支持条件变量</strong>：<code>std::unique_lock</code>可以与<code>std::condition_variable</code>一起使用，用于等待条件或通知其他线程。<code>std::condition_variable</code>需要与<code>std::unique_lock&lt;std::mutex&gt;</code>一起使用来等待条件或发送通知。</p>
</li>
<li>
<p><strong>支持移动语义</strong>：<code>std::unique_lock</code>支持移动操作，这意味着可以将锁的所有权从一个<code>std::unique_lock</code>对象转移到另一个。这对于从函数返回已锁定的互斥锁或将其作为参数传递给函数等操作非常有用。</p>
</li>
</ol>
<h3 id="示例用法">
  示例用法
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8b%e7%94%a8%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>std<span style="color:#f92672">::</span>mutex mtx; <span style="color:#75715e">// 全局互斥锁
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_block</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">char</span> c) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>    <span style="color:#75715e">// 在std::unique_lock对象构造时加锁
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>unique_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(mtx);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> c; }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>    <span style="color:#75715e">// lock在析构时自动解锁
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(print_block, <span style="color:#ae81ff">50</span>, <span style="color:#e6db74">&#39;*&#39;</span>);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(print_block, <span style="color:#ae81ff">50</span>, <span style="color:#e6db74">&#39;$&#39;</span>);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>    t1.join();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>    t2.join();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span>}
</span></span></code></pre></div><p>在这个例子中，两个线程使用同一个互斥锁来同步对<code>std::cout</code>的访问。<code>std::unique_lock&lt;std::mutex&gt;</code>在<code>print_block</code>函数中创建并自动管理锁的生命周期：自动加锁和在离开作用域时解锁。</p>
<p>总之，<code>std::unique_lock</code>提供了一种灵活的方式来控制互斥锁的锁定和解锁，特别适合需要条件变量、可移动锁、或者需要在运行时进行更复杂的锁管理操作的场景。</p>
<h2 id="cv的条件变为真的时候谁来唤醒呢">
  CV的条件变为真的时候，谁来唤醒呢？
  <a class="heading-link" href="#cv%e7%9a%84%e6%9d%a1%e4%bb%b6%e5%8f%98%e4%b8%ba%e7%9c%9f%e7%9a%84%e6%97%b6%e5%80%99%e8%b0%81%e6%9d%a5%e5%94%a4%e9%86%92%e5%91%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>条件变为真时，线程被唤醒通常是由其他线程执行的操作导致的。这些操作包括调用<code>std::condition_variable</code>的<code>notify_one</code>或<code>notify_all</code>成员函数。这两个函数的作用是通知正在等待的一个或所有线程（分别对应<code>notify_one</code>和<code>notify_all</code>），条件可能已经满足，等待的线程应该再次检查条件。</p>
<p>这里是如何使用它们的简化示例：</p>
<ul>
<li>
<p><strong><code>notify_one</code></strong>: 当条件变为真时，某个线程调用<code>cv.notify_one()</code>会唤醒一个正在等待（通过<code>cv.wait()</code>或<code>cv.wait_for()</code>等方法）的线程。如果有多个线程在等待，只有一个线程（由调度程序随机选择）会被唤醒。</p>
</li>
<li>
<p><strong><code>notify_all</code></strong>: 相比之下，当条件变为真时，调用<code>cv.notify_all()</code>会唤醒所有正在等待的线程。这对于需要多个线程响应同一个事件的情况特别有用。</p>
</li>
</ul>
<h3 id="示例场景">
  示例场景
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8b%e5%9c%ba%e6%99%af">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>假设有两个线程A和B：</p>
<ul>
<li>线程A执行某个任务，完成后需要通知线程B任务已完成，线程B可以开始执行依赖于A的任务。</li>
<li>线程A在完成任务后调用<code>cv.notify_one()</code>或<code>cv.notify_all()</code>（假设只有线程B在等待，两者效果相同）。</li>
<li>线程B在开始自己的任务前调用<code>cv.wait(lock, predicate)</code>等待线程A的通知。一旦线程A调用了<code>notify_one()</code>或<code>notify_all()</code>，线程B被唤醒。</li>
<li>被唤醒后，线程B会自动重新获得之前<code>wait</code>操作中释放的锁，并重新检查条件（谓词函数）。如果条件满足，线程B继续执行后续操作；如果不满足（虽然被唤醒，但条件可能由于某些原因未真正满足），线程B会再次进入等待状态。</li>
</ul>
<p>这种机制确保了线程间的协作和同步，允许线程在适当的时间点安全地进行操作，避免了资源竞争和不一致的风险。</p>
<h2 id="如何实现断点续传">
  如何实现断点续传
  <a class="heading-link" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>实现断点续传的关键在于能够记录下载或上传的当前进度，并在传输被中断后能够从该进度处恢复而不是重新开始。断点续传通常用于处理大文件传输，尤其是在网络条件不稳定的情况下。以下是实现断点续传功能的基本步骤和策略：</p>
<h3 id="1-记录传输进度">
  1. 记录传输进度
  <a class="heading-link" href="#1-%e8%ae%b0%e5%bd%95%e4%bc%a0%e8%be%93%e8%bf%9b%e5%ba%a6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>客户端和服务器都需要记录文件的传输进度</strong>。这可以通过保存已经传输的数据量（字节）来实现，或者记录已经成功传输的文件块的标识。</li>
</ul>
<h3 id="2-支持范围请求">
  2. 支持范围请求
  <a class="heading-link" href="#2-%e6%94%af%e6%8c%81%e8%8c%83%e5%9b%b4%e8%af%b7%e6%b1%82">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>服务器需要支持范围请求（HTTP协议的<code>Range</code>头部）</strong>。这允许客户端请求文件的特定部分而不是整个文件。客户端可以通过发送一个包含<code>Range</code>头部的HTTP请求来实现，指定需要下载的文件部分的起始和结束字节位置。</li>
</ul>
<h3 id="3-客户端请求特定数据块">
  3. 客户端请求特定数据块
  <a class="heading-link" href="#3-%e5%ae%a2%e6%88%b7%e7%ab%af%e8%af%b7%e6%b1%82%e7%89%b9%e5%ae%9a%e6%95%b0%e6%8d%ae%e5%9d%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>客户端在恢复下载时请求未完成的数据块</strong>。基于已记录的进度，客户端计算出需要从哪个字节位置开始恢复下载，并发送带有<code>Range</code>头部的请求。</li>
</ul>
<h3 id="4-服务器响应范围请求">
  4. 服务器响应范围请求
  <a class="heading-link" href="#4-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%93%8d%e5%ba%94%e8%8c%83%e5%9b%b4%e8%af%b7%e6%b1%82">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>服务器识别<code>Range</code>请求并发送相应的文件片段</strong>。服务器需要正确处理带有<code>Range</code>头部的请求，只发送请求的文件部分。</li>
</ul>
<h3 id="5-校验和完整性验证">
  5. 校验和完整性验证
  <a class="heading-link" href="#5-%e6%a0%a1%e9%aa%8c%e5%92%8c%e5%ae%8c%e6%95%b4%e6%80%a7%e9%aa%8c%e8%af%81">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>使用校验和或哈希来确保数据完整性</strong>。在传输完成后，客户端可以对接收到的文件片段或整个文件计算校验和或哈希值，与服务器端提供的值进行比较，以验证数据的完整性和正确性。</li>
</ul>
<h3 id="示例http断点续传">
  示例：HTTP断点续传
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8bhttp%e6%96%ad%e7%82%b9%e7%bb%ad%e4%bc%a0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>假设客户端已经下载了文件的前1024字节，现在希望从第1025字节开始继续下载：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#a6e22e">GET</span> /path/to/file <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">example.com</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>Range<span style="color:#f92672">:</span> <span style="color:#ae81ff">bytes=1025-</span>
</span></span></code></pre></div><p>服务器响应：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-http" data-lang="http"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">206</span> <span style="color:#a6e22e">Partial Content</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>Content-Range<span style="color:#f92672">:</span> <span style="color:#ae81ff">bytes 1025-2048/2049</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>Content-Length<span style="color:#f92672">:</span> <span style="color:#ae81ff">1024</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>[数据块]
</span></span></code></pre></div><h3 id="实现注意事项">
  实现注意事项
  <a class="heading-link" href="#%e5%ae%9e%e7%8e%b0%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>持久化进度信息</strong>：为了在客户端或服务器重启后能够恢复传输，进度信息需要被持久化存储，例如保存在文件系统或数据库中。</li>
<li><strong>并发控制</strong>：如果支持多个客户端同时对同一文件进行断点续传，需要实现适当的并发控制机制，以防止数据冲突。</li>
<li><strong>安全性</strong>：在设计断点续传功能时，应考虑到数据传输的安全性，使用加密连接（如HTTPS）来保护传输过程中的数据。</li>
</ul>
<p>通过上述步骤和策略，可以有效实现文件的断点续传功能，提高大文件传输的效率和可靠性，尤其是在网络环境不稳定的情况下。</p>
<h2 id="explicit关键字在c中的作用">
  explicit关键字在C++中的作用
  <a class="heading-link" href="#explicit%e5%85%b3%e9%94%ae%e5%ad%97%e5%9c%a8c%e4%b8%ad%e7%9a%84%e4%bd%9c%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，<code>explicit</code>关键字用于修饰类的构造函数，以防止隐式类型转换或拷贝初始化。使用<code>explicit</code>关键字可以避免因不经意的类型转换而导致的错误，使代码的意图更加清晰。</p>
<h3 id="隐式类型转换">
  隐式类型转换
  <a class="heading-link" href="#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>默认情况下，如果一个构造函数只接受一个参数，或者所有参数除了一个都有默认值，那么它可以被用于隐式类型转换。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>    MyClass(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>        <span style="color:#75715e">// 构造函数的实现
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(MyClass obj) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>    <span style="color:#75715e">// func的实现
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    func(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// 隐式调用 MyClass(int) 构造函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>}
</span></span></code></pre></div><p>在上面的例子中，当<code>func(10)</code>被调用时，整数<code>10</code>会隐式地被用来构造一个<code>MyClass</code>的对象，因为<code>MyClass</code>有一个接受<code>int</code>类型参数的构造函数。</p>
<h3 id="使用explicit防止隐式转换">
  使用<code>explicit</code>防止隐式转换
  <a class="heading-link" href="#%e4%bd%bf%e7%94%a8explicit%e9%98%b2%e6%ad%a2%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>要防止这种隐式类型转换，可以在构造函数前加上<code>explicit</code>关键字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>    <span style="color:#66d9ef">explicit</span> MyClass(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>        <span style="color:#75715e">// 构造函数的实现
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(MyClass obj) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>    <span style="color:#75715e">// func的实现
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    func(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// 这会引发编译错误
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span><span style="color:#75715e"></span>    func(MyClass(<span style="color:#ae81ff">10</span>)); <span style="color:#75715e">// 正确的调用方式
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>}
</span></span></code></pre></div><p>通过将构造函数声明为<code>explicit</code>，你告诉编译器不允许使用该构造函数进行隐式类型转换。这样，除非显式地调用构造函数（如<code>MyClass(10)</code>），否则编译器会报错。</p>
<h3 id="explicit的作用域">
  <code>explicit</code>的作用域
  <a class="heading-link" href="#explicit%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>C++11之前，<code>explicit</code>关键字只能用于修饰只接受一个参数的构造函数。</li>
<li>从C++11开始，<code>explicit</code>可以用于修饰接受多个参数的构造函数，以及转换运算符。</li>
</ul>
<p>例如，防止类的对象被隐式转换为其他类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>    <span style="color:#75715e">// 构造函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">explicit</span> MyClass(<span style="color:#66d9ef">int</span> x) {}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>    <span style="color:#75715e">// 转换运算符
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">explicit</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">bool</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>    MyClass obj(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> obj; <span style="color:#75715e">// 这会引发编译错误
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> flag2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(obj); <span style="color:#75715e">// 正确的调用方式
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>}
</span></span></code></pre></div><p>使用<code>explicit</code>关键字是一种良好的编程实践，它可以增加代码的安全性和可读性，防止意外的类型转换导致的错误。</p>
<h2 id="链表和数组的区别">
  链表和数组的区别
  <a class="heading-link" href="#%e9%93%be%e8%a1%a8%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="队列和栈的区别">
  队列和栈的区别
  <a class="heading-link" href="#%e9%98%9f%e5%88%97%e5%92%8c%e6%a0%88%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="二叉树先序遍历中序遍历后序遍历">
  二叉树先序遍历、中序遍历、后序遍历
  <a class="heading-link" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e5%85%88%e5%ba%8f%e9%81%8d%e5%8e%86%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="引用和指针的区别">
  引用和指针的区别
  <a class="heading-link" href="#%e5%bc%95%e7%94%a8%e5%92%8c%e6%8c%87%e9%92%88%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="usingtypedef和define有什么区别">
  using,typedef和define有什么区别
  <a class="heading-link" href="#usingtypedef%e5%92%8cdefine%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>using</code>、<code>typedef</code>和<code>define</code>在C++中都是与类型和符号定义相关的语法元素，但它们在用法、功能和适用范围上有着明显的不同。</p>
<h3 id="typedef">
  <code>typedef</code>
  <a class="heading-link" href="#typedef">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>typedef</code>是C和C++中用来为类型定义一个新名字的关键字。它常用于简化复杂类型的名称，提高代码的可读性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> ulong;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>FuncPtr)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span>);
</span></span></code></pre></div><p>上述例子中，<code>ulong</code>成为了<code>unsigned long</code>的别名，<code>FuncPtr</code>成为了指向特定函数的指针类型的别名。</p>
<h3 id="using">
  <code>using</code>
  <a class="heading-link" href="#using">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>using</code>是C++11引入的类型别名声明的新语法，功能上与<code>typedef</code>相似，但语法更加直观，尤其是在定义模板别名时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">using</span> ulong <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">using</span> FuncPtr <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span>);
</span></span></code></pre></div><p>对于模板别名，<code>using</code>的优势更为明显：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">using</span> Ptr <span style="color:#f92672">=</span> T<span style="color:#f92672">*</span>;
</span></span></code></pre></div><p>上述代码定义了一个模板别名<code>Ptr</code>，可以用于任意类型的指针。</p>
<h3 id="define">
  <code>#define</code>
  <a class="heading-link" href="#define">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>#define</code>是C和C++中的预处理指令，用于定义宏。它在编译前对代码进行文本替换，可以用来定义常量值、函数宏，或是进行条件编译等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#75715e">#define PI 3.14159
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#75715e">#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))
</span></span></span></code></pre></div><h3 id="主要区别">
  主要区别
  <a class="heading-link" href="#%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>作用范围</strong>：<code>typedef</code>和<code>using</code>仅用于类型别名，增强代码可读性和简化复杂类型声明。<code>#define</code>是预处理指令，功能更广泛，但主要用于宏定义和条件编译。</li>
<li><strong>类型安全</strong>：<code>typedef</code>和<code>using</code>是类型安全的，它们定义的别名完全等同于原类型。<code>#define</code>进行的是文本替换，不涉及类型检查，有可能导致难以追踪的错误。</li>
<li><strong>适用范围</strong>：<code>typedef</code>和<code>using</code>仅适用于类型定义，而<code>#define</code>几乎可以用于定义任何文本替换。</li>
<li><strong>编译阶段</strong>：<code>typedef</code>和<code>using</code>在编译阶段处理，<code>#define</code>在预处理阶段处理。</li>
</ul>
<p>总结来说，尽管<code>typedef</code>、<code>using</code>和<code>#define</code>在某些场景下可能看起来有相似的作用（如定义别名），但它们的用途、功能和适用范围有很大差别。在现代C++编程中，推荐使用<code>using</code>来定义类型别名，因为它比<code>typedef</code>更灵活，且语义更清晰。而<code>#define</code>因其灵活性和潜在的风险，在定义常量和类型别名时应谨慎使用，更多的是用于条件编译等场景。</p>
<h2 id="const修饰成员函数会怎么样可以有两个f其中一个带const另一个不带吗">
  const修饰成员函数会怎么样？可以有两个f(),其中一个带const,另一个不带吗?
  <a class="heading-link" href="#const%e4%bf%ae%e9%a5%b0%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e4%bc%9a%e6%80%8e%e4%b9%88%e6%a0%b7%e5%8f%af%e4%bb%a5%e6%9c%89%e4%b8%a4%e4%b8%aaf%e5%85%b6%e4%b8%ad%e4%b8%80%e4%b8%aa%e5%b8%a6const%e5%8f%a6%e4%b8%80%e4%b8%aa%e4%b8%8d%e5%b8%a6%e5%90%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="static定义的变量默认值是多少普通变量呢">
  static定义的变量默认值是多少？普通变量呢？
  <a class="heading-link" href="#static%e5%ae%9a%e4%b9%89%e7%9a%84%e5%8f%98%e9%87%8f%e9%bb%98%e8%ae%a4%e5%80%bc%e6%98%af%e5%a4%9a%e5%b0%91%e6%99%ae%e9%80%9a%e5%8f%98%e9%87%8f%e5%91%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="extern有什么作用">
  extern有什么作用
  <a class="heading-link" href="#extern%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="简述指针常量与常量指针区别">
  简述指针常量与常量指针区别
  <a class="heading-link" href="#%e7%ae%80%e8%bf%b0%e6%8c%87%e9%92%88%e5%b8%b8%e9%87%8f%e4%b8%8e%e5%b8%b8%e9%87%8f%e6%8c%87%e9%92%88%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="构造函数能否为虚函数">
  构造函数能否为虚函数
  <a class="heading-link" href="#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e8%83%bd%e5%90%a6%e4%b8%ba%e8%99%9a%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="为什么基类的析构函数需要是序函数">
  为什么基类的析构函数需要是序函数？
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%9f%ba%e7%b1%bb%e7%9a%84%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e9%9c%80%e8%a6%81%e6%98%af%e5%ba%8f%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="重载隐藏重写覆盖三者的区别">
  重载、隐藏、重写（覆盖）三者的区别？
  <a class="heading-link" href="#%e9%87%8d%e8%bd%bd%e9%9a%90%e8%97%8f%e9%87%8d%e5%86%99%e8%a6%86%e7%9b%96%e4%b8%89%e8%80%85%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型（统一为void，否则报错）。</p>
<p>隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</p>
<p>重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p>
<p>重载的参数不同,函数体不同；隐藏的参数可以不同，函数体不同；重写或者覆盖仅仅函数体不同。</p>
<h2 id="重载为什么改变参数就可以实现调用不同的函数">
  重载为什么改变参数就可以实现调用不同的函数？
  <a class="heading-link" href="#%e9%87%8d%e8%bd%bd%e4%b8%ba%e4%bb%80%e4%b9%88%e6%94%b9%e5%8f%98%e5%8f%82%e6%95%b0%e5%b0%b1%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e8%b0%83%e7%94%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>重载（Overloading）是一种允许多个在同一作用域内的函数或操作符拥有相同名称，但是参数类型、个数或顺序不同的编程技术。编译器根据这些不同的参数列表来区分它们，这个过程称为重载解析（Overload Resolution）。当一个重载的函数被调用时，编译器通过匹配调用中使用的参数类型和数量，选择最合适的重载版本执行。下面解释为什么通过改变参数可以实现调用不同的函数：</p>
<h3 id="参数类型数量和顺序的不同">
  参数类型、数量和顺序的不同
  <a class="heading-link" href="#%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b%e6%95%b0%e9%87%8f%e5%92%8c%e9%a1%ba%e5%ba%8f%e7%9a%84%e4%b8%8d%e5%90%8c">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>类型</strong>：如果两个函数的参数数量相同，但参数类型不同，编译器可以根据传递给函数的实参类型来决定调用哪个函数。</p>
</li>
<li>
<p><strong>数量</strong>：如果两个函数的参数类型相同或者兼容，但参数数量不同，编译器会根据传递的参数数量来决定调用哪个函数。</p>
</li>
<li>
<p><strong>顺序</strong>：如果两个函数的参数数量和类型都相同，但参数的顺序不同，编译器同样可以根据传递的参数的顺序来决定调用哪个函数。</p>
</li>
</ol>
<h3 id="编译器的重载解析过程">
  编译器的重载解析过程
  <a class="heading-link" href="#%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e9%87%8d%e8%bd%bd%e8%a7%a3%e6%9e%90%e8%bf%87%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>当调用一个重载的函数时，编译器执行一个重载解析过程，按照以下步骤：</p>
<ol>
<li>
<p><strong>候选函数集合</strong>：收集所有与调用匹配的重载函数，包括那些参数可以通过隐式转换匹配的函数。</p>
</li>
<li>
<p><strong>可行函数集合</strong>：从候选函数中筛选出实参可以被隐式转换以匹配形参类型的函数。</p>
</li>
<li>
<p><strong>最佳匹配</strong>：从可行函数中选择“最佳匹配”的函数。编译器会根据类型匹配的精确度（如是否需要类型转换，转换的复杂程度等）来决定最佳匹配。</p>
</li>
<li>
<p><strong>调用</strong>：根据最佳匹配调用相应的函数。</p>
</li>
</ol>
<p>如果编译器无法找到一个明确的最佳匹配，或者找到多个同样好的匹配，就会产生一个重载解析的歧义，编译时会报错。</p>
<h3 id="重载的实用性">
  重载的实用性
  <a class="heading-link" href="#%e9%87%8d%e8%bd%bd%e7%9a%84%e5%ae%9e%e7%94%a8%e6%80%a7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>重载使得函数名可以根据上下文有不同的行为，提高了代码的可读性和易用性。例如，标准库中的<code>std::cout</code>就重载了多种类型的<code>&lt;&lt;</code>操作符，使得我们可以方便地输出不同类型的数据。</p>
<h3 id="示例">
  示例
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">int</span> i) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Integer: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">double</span> f) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Double: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> f <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;</span> s) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;String: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>    print(<span style="color:#ae81ff">10</span>);    <span style="color:#75715e">// 调用 print(int)
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#75715e"></span>    print(<span style="color:#ae81ff">3.14</span>);  <span style="color:#75715e">// 调用 print(double)
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span><span style="color:#75715e"></span>    print(<span style="color:#e6db74">&#34;Hello&#34;</span>); <span style="color:#75715e">// 调用 print(const std::string&amp;)
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在这个例子中，<code>print</code>函数被重载了三次，分别接受<code>int</code>、<code>double</code>和<code>std::string</code>类型的参数。编译器根据传递给<code>print</code>函数的参数类型来决定调用哪一个重载版本。</p>
<p>通过这种方式，重载为编程提供了更高的灵活性和表达力。</p>
<h2 id="重载对链接有什么影响重载的底层实现">
  重载对链接有什么影响？重载的底层实现？
  <a class="heading-link" href="#%e9%87%8d%e8%bd%bd%e5%af%b9%e9%93%be%e6%8e%a5%e6%9c%89%e4%bb%80%e4%b9%88%e5%bd%b1%e5%93%8d%e9%87%8d%e8%bd%bd%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>函数重载在编译阶段对函数名进行了修饰（或称为名字改编、名字矫正、mangling），以保证每个重载函数在程序的链接阶段有一个唯一的标识。这个过程对链接有重要影响，因为它确保了链接器可以正确地区分和链接各个重载函数，即使它们有相同的基础名称。</p>
<h3 id="名字修饰name-mangling">
  名字修饰（Name Mangling）
  <a class="heading-link" href="#%e5%90%8d%e5%ad%97%e4%bf%ae%e9%a5%b0name-mangling">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>定义</strong>：名字修饰是一种编译器技术，用于在内部符号表中生成唯一的函数和变量标识符。对于重载函数，编译器将函数的名称、参数类型列表（有时还包括命名空间或类名称）编码到生成的唯一标识符中。</li>
<li><strong>目的</strong>：主要目的是解决名称冲突问题，特别是在函数重载和模板实例化的情况下，这些情况下可能会有多个实体共享相同的名称。</li>
</ul>
<h3 id="链接阶段的影响">
  链接阶段的影响
  <a class="heading-link" href="#%e9%93%be%e6%8e%a5%e9%98%b6%e6%ae%b5%e7%9a%84%e5%bd%b1%e5%93%8d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在链接阶段，链接器需要解析程序中的所有外部符号引用，将它们与相应的符号定义匹配起来。由于名字修饰，每个重载函数都有了独特的内部名称，链接器可以正确地识别和链接到正确的函数实现，即使多个函数具有相同的基本名称。</p>
<h3 id="不同编译器的差异">
  不同编译器的差异
  <a class="heading-link" href="#%e4%b8%8d%e5%90%8c%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e5%b7%ae%e5%bc%82">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>不同的编译器可能采用不同的名字修饰规则。这意味着用不同编译器编译的代码在链接时可能会因为名字修饰的不兼容而遇到问题，尤其是在尝试链接不同编译器生成的二进制库时。为了解决这个问题，可以采用以下策略：</p>
<ul>
<li><strong>使用相同的编译器</strong>：对于需要链接在一起的所有模块，尽量使用相同的编译器和编译选项。</li>
<li><strong>C语言接口</strong>：对于C++库，如果需要与使用不同编译器的代码链接，可以提供一个“纯C”的接口，因为C语言没有函数重载，也不进行名字修饰，具有更好的二进制兼容性。</li>
<li><strong>外部接口（Extern &ldquo;C&rdquo;）</strong>：在C++中，可以使用<code>extern &quot;C&quot;</code>来告诉C++编译器对于特定的函数或变量不要进行名字修饰，从而使得这些符号能够被不同编译器编译的代码所链接。</li>
</ul>
<p>通过这些方法，可以减少或避免由于名字修饰规则差异导致的链接问题，确保重载函数的正确链接和使用。</p>
<h2 id="构造函数可以被重载么析构函数呢">
  构造函数可以被重载么？析构函数呢？
  <a class="heading-link" href="#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e8%a2%ab%e9%87%8d%e8%bd%bd%e4%b9%88%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e5%91%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="new和malloc有什么区别">
  new和malloc有什么区别?
  <a class="heading-link" href="#new%e5%92%8cmalloc%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="new-operator和operator-new的区别">
  new operator和operator new的区别？
  <a class="heading-link" href="#new-operator%e5%92%8coperator-new%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，<code>new</code>操作符和<code>operator new</code>函数经常令人混淆，但它们有着明显的不同和各自的作用。</p>
<h3 id="new操作符">
  <code>new</code>操作符
  <a class="heading-link" href="#new%e6%93%8d%e4%bd%9c%e7%ac%a6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>new</code>操作符用于动态分配内存并调用构造函数初始化对象。它是一个高级操作，执行了两个主要步骤：</p>
<ol>
<li><strong>内存分配</strong>：首先，<code>new</code>操作符调用<code>operator new</code>函数分配足够的内存以容纳特定类型的对象。这是一个底层操作，仅负责分配内存，并不负责构造对象。</li>
<li><strong>构造对象</strong>：然后，在分配的内存上调用对象的构造函数来初始化对象。</li>
</ol>
<p>这个过程可以通过下面的例子来说明：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>MyClass<span style="color:#f92672">*</span> obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass();
</span></span></code></pre></div><p>上面的代码首先使用<code>operator new</code>分配足够的内存来存储一个<code>MyClass</code>类型的对象，然后在这块内存上调用<code>MyClass</code>的默认构造函数初始化对象。</p>
<h3 id="operator-new函数">
  <code>operator new</code>函数
  <a class="heading-link" href="#operator-new%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>operator new</code>是一个全局函数或者类成员函数，仅负责分配内存，不涉及对象的构造。它是<code>new</code>操作符背后的内存分配机制。当你使用<code>new</code>操作符时，实际上是隐式调用了<code>operator new</code>函数来分配内存。</p>
<p>如果需要，可以重载<code>operator new</code>来提供自定义的内存分配策略。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t size) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>    <span style="color:#75715e">// 自定义内存分配逻辑
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> malloc(size);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>    <span style="color:#75715e">// 处理内存分配失败的情况
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p) <span style="color:#66d9ef">throw</span> std<span style="color:#f92672">::</span>bad_alloc();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span>}
</span></span></code></pre></div><p>需要注意的是，重载<code>operator new</code>需要非常谨慎，因为它会改变程序的基本内存分配行为。</p>
<h3 id="总结-2">
  总结
  <a class="heading-link" href="#%e6%80%bb%e7%bb%93-2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><code>new</code>操作符是一个高级操作，用于分配内存并初始化对象。</li>
<li><code>operator new</code>函数是一个底层操作，仅用于分配内存，不负责对象的构造。</li>
<li>在执行<code>new</code>操作符时，实际上会调用<code>operator new</code>函数来分配内存，然后在分配的内存上调用构造函数来构造对象。</li>
<li>可以重载<code>operator new</code>和<code>operator delete</code>来提供自定义的内存分配和释放策略，但需要谨慎操作，以避免意外的行为。</li>
</ul>
<h2 id="深入解析newoperator-newnewplacement-new">
  深入解析new、operator new、::new、placement new
  <a class="heading-link" href="#%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90newoperator-newnewplacement-new">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><a href="https://blog.csdn.net/songchuwang1868/article/details/81353577"  class="external-link" target="_blank" rel="noopener">https://blog.csdn.net/songchuwang1868/article/details/81353577</a></p>
<p>在C++中，<code>new</code>操作的不同形式提供了内存分配和对象构造的灵活手段。深入理解它们之间的区别对于编写高效、可靠的C++代码非常重要。下面是对<code>new</code>、<code>operator new</code>、<code>::new</code>和<code>placement new</code>的深入解析：</p>
<h3 id="1-new操作符">
  1. <code>new</code>操作符
  <a class="heading-link" href="#1-new%e6%93%8d%e4%bd%9c%e7%ac%a6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>new</code>操作符用于动态分配内存，并调用构造函数初始化对象。它是一个高级操作，封装了内存分配和对象构造两个步骤：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>MyClass<span style="color:#f92672">*</span> obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyClass(args);
</span></span></code></pre></div><p>上述代码首先调用<code>operator new</code>函数分配足够的内存来存储<code>MyClass</code>类型的对象，然后在分配的内存上调用<code>MyClass</code>的构造函数，使用<code>args</code>作为参数。</p>
<h3 id="2-operator-new函数">
  2. <code>operator new</code>函数
  <a class="heading-link" href="#2-operator-new%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>operator new</code>是一个全局函数或类成员函数，负责分配内存。当使用<code>new</code>操作符时，背后就是调用<code>operator new</code>来进行内存分配。与<code>new</code>操作符不同，<code>operator new</code>仅分配内存，不负责构造对象：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(<span style="color:#66d9ef">sizeof</span>(MyClass));
</span></span></code></pre></div><p>可以重载<code>operator new</code>来自定义内存分配策略。</p>
<h3 id="3-new">
  3. <code>::new</code>
  <a class="heading-link" href="#3-new">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>::new</code>指的是全局作用域下的<code>new</code>操作符，用来明确调用全局的<code>operator new</code>函数，而不是某个类的重载版本。这在有重载<code>operator new</code>的情况下很有用，确保调用的是全局版本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>MyClass<span style="color:#f92672">*</span> obj <span style="color:#f92672">=</span> <span style="color:#f92672">::</span><span style="color:#66d9ef">new</span> MyClass(args);
</span></span></code></pre></div><h3 id="4-placement-new">
  4. Placement new
  <a class="heading-link" href="#4-placement-new">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>placement new</code>允许在已分配的内存上构造对象。这种方式不分配内存，只调用对象的构造函数。<code>placement new</code>非常有用，特别是在需要在特定位置构造对象的场景中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(MyClass)); <span style="color:#75715e">// 先分配内存
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#75715e"></span>MyClass<span style="color:#f92672">*</span> obj <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span>(ptr) MyClass(args); <span style="color:#75715e">// 在ptr指向的内存上构造对象
</span></span></span></code></pre></div><p>需要注意的是，使用<code>placement new</code>时，应当手动调用对象的析构函数，并负责释放内存：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>obj<span style="color:#f92672">-&gt;~</span>MyClass(); <span style="color:#75715e">// 调用析构函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#75715e"></span>free(ptr); <span style="color:#75715e">// 释放内存
</span></span></span></code></pre></div><h3 id="总结-3">
  总结
  <a class="heading-link" href="#%e6%80%bb%e7%bb%93-3">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong><code>new</code>操作符</strong>：高级操作，分配内存并构造对象。</li>
<li><strong><code>operator new</code>函数</strong>：底层操作，仅分配内存，可被重载。</li>
<li><strong><code>::new</code></strong>：使用全局<code>operator new</code>，避免调用类的重载版本。</li>
<li><strong><code>placement new</code></strong>：在指定内存位置构造对象，不分配内存，需要手动管理内存和析构。</li>
</ul>
<p>理解这些不同的<code>new</code>形式及其用途，可以帮助开发者更有效地管理内存和对象的生命周期，编写出更加精细控制和高效的C++代码。</p>
<h2 id="虚函数表的结构是怎样的">
  虚函数表的结构是怎样的？
  <a class="heading-link" href="#%e8%99%9a%e5%87%bd%e6%95%b0%e8%a1%a8%e7%9a%84%e7%bb%93%e6%9e%84%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>虚函数表是一个函数指针数组，数组里存放的都是函数指针，指向虚函数所在的位置。 对象调用虚函数时，会根据虚指针找到虚表的位置，再根据虚函数声明的顺序找到虚函数在数组的哪个位置，找到虚函数的地址，从而调用虚函数。</p>
<h2 id="ab两个类类中有虚函数c继承ab有几张虚函数表">
  A,B两个类，类中有虚函数。C继承AB，有几张虚函数表？
  <a class="heading-link" href="#ab%e4%b8%a4%e4%b8%aa%e7%b1%bb%e7%b1%bb%e4%b8%ad%e6%9c%89%e8%99%9a%e5%87%bd%e6%95%b0c%e7%bb%a7%e6%89%bfab%e6%9c%89%e5%87%a0%e5%bc%a0%e8%99%9a%e5%87%bd%e6%95%b0%e8%a1%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>答：2张</p>
<p>再问：为什么2张？</p>
<p>多继承就会有多个虚函数表。因为每个父类的虚函数是不同的，指针也是不同的。</p>
<p>如果共用一张虚函数表，就分不清到底子类的实例化是针对哪一个基函数的。</p>
<h2 id="为什么不应该在构造函数中调用虚函数">
  为什么不应该在构造函数中调用虚函数
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e5%ba%94%e8%af%a5%e5%9c%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%ad%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，父类（基类）的构造函数中调用虚函数是合法的，但这可能不会按照初学者期望的方式工作。在基类构造期间调用虚函数时，并不会调用派生类（子类）中的重写版本，即使是在构造派生类对象的过程中。相反，会调用基类中该虚函数的版本，或者是更上层基类中该虚函数最近的重写版本。这是因为在基类构造期间，对象类型被视为基类类型，而不是派生类类型，从而防止了对尚未完全构造的对象执行操作。</p>
<h3 id="为什么不应该在构造函数中调用虚函数-1">
  为什么不应该在构造函数中调用虚函数
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e5%ba%94%e8%af%a5%e5%9c%a8%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%ad%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0-1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>调用尚未完全构造的对象的成员函数可能会导致未定义行为或错误。如果虚函数依赖于派生类中的某些成员变量，而这些成员变量在基类构造函数被调用时尚未初始化，那么虚函数可能无法正常工作或产生错误结果。</p>
<h3 id="示例-1">
  示例
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8b-1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>考虑以下示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>    Base() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>        callVirtual();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">callVirtual</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Base version of callVirtual</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>    Derived() <span style="color:#f92672">:</span> Base() {}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">callVirtual</span>() <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Derived version of callVirtual</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span><span>    Derived d;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span><span>}
</span></span></code></pre></div><p>输出将是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>Base version of callVirtual
</span></span></code></pre></div><p>尽管<code>Derived</code>对象被构造，但在<code>Base</code>构造函数中调用<code>callVirtual()</code>时，只会调用<code>Base</code>类中的<code>callVirtual()</code>版本，而不是<code>Derived</code>类中重写的版本。</p>
<h3 id="最佳实践">
  最佳实践
  <a class="heading-link" href="#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>为了避免潜在的错误和混淆，最佳实践是在构造函数和析构函数中避免调用虚函数。如果需要在对象构造期间执行某些操作，并且这些操作需要在派生类中进行特定的实现，考虑使用其他设计模式，如工厂模式，其中对象在完全构造后立即进行初始化，或者通过非虚成员函数调用虚函数，该非虚成员函数在对象构造完成后明确调用。</p>
<p>在构造函数中调用虚函数通常不是一个好的做法，原因主要涉及到对象的构造过程和多态行为的安全性。这里有几个关键点解释了为什么在构造函数中调用虚函数可能会导致问题：</p>
<h3 id="1-对象构造的阶段性">
  1. 对象构造的阶段性
  <a class="heading-link" href="#1-%e5%af%b9%e8%b1%a1%e6%9e%84%e9%80%a0%e7%9a%84%e9%98%b6%e6%ae%b5%e6%80%a7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>当创建一个派生类的对象时，对象的构造是按顺序进行的，从基类开始，然后是派生类。在基类的构造函数执行期间，派生类的部分还没有被构造。这意味着，如果在基类构造函数中调用了一个虚函数，该虚函数如果被派生类重写，那么调用的将是基类版本的实现，即使这个调用发生在派生类的构造函数的上下文中。这是因为此时对象的动态类型仍然是基类，而非派生类，C++的多态性在此时还未完全建立。</p>
<h3 id="2-安全性和一致性">
  2. 安全性和一致性
  <a class="heading-link" href="#2-%e5%ae%89%e5%85%a8%e6%80%a7%e5%92%8c%e4%b8%80%e8%87%b4%e6%80%a7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>如果虚函数在基类构造期间被调用，并且该虚函数被派生类重写，由于派生类的构造器尚未执行，任何由派生类添加的成员变量都还未被初始化。如果重写的虚函数依赖于这些成员变量，那么它可能会访问未初始化的变量，导致未定义行为或程序错误。</p>
<h3 id="3-设计上的限制">
  3. 设计上的限制
  <a class="heading-link" href="#3-%e8%ae%be%e8%ae%a1%e4%b8%8a%e7%9a%84%e9%99%90%e5%88%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在构造函数中调用虚函数强加了设计上的限制，即要求派生类在其虚函数实现中只能使用那些在基类构造期间就已经初始化完毕的资源。这限制了派生类设计的灵活性，使得派生类的开发者需要对基类的内部实现细节有深入的了解。</p>
<h3 id="替代方案">
  替代方案
  <a class="heading-link" href="#%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>为了避免这些问题，通常建议不在构造函数（以及析构函数）中调用虚函数。作为替代，可以考虑以下设计策略：</p>
<ul>
<li><strong>延迟初始化</strong>：通过在构造函数之后显式调用初始化函数来进行操作，这可以确保对象完全构造后再进行多态行为的相关操作。</li>
<li><strong>非虚成员函数调用</strong>：在构造函数中调用一个非虚成员函数，该非虚成员函数然后再调用一个虚函数。这样做同样需要小心，以确保不违反上述原则。</li>
<li><strong>设计模式</strong>：考虑使用工厂模式或者建造者模式来创建对象，这样可以在对象完全构造好之后再执行需要多态行为的操作。</li>
</ul>
<p>通过遵循这些指导原则，可以避免在对象构造期间因调用虚函数而可能引入的问题，使得代码更加安全和健壮。</p>
<h3 id="上面都是gpt下面是人话">
  上面都是GPT，下面是人话
  <a class="heading-link" href="#%e4%b8%8a%e9%9d%a2%e9%83%bd%e6%98%afgpt%e4%b8%8b%e9%9d%a2%e6%98%af%e4%ba%ba%e8%af%9d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</p>
<p>这种行为有两个理由：</p>
<p>第一个理由是概念上的。</p>
<p>在概念上，构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象——我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员，这将导致灾难发生。</p>
<p>第二个理由是机械上的。</p>
<p>当一个构造函数被调用时，它做的首要的事情之一就是初始化它的VPTR。然而，它只能知道它属于“当前”类——即构造函数所在的类。于是它完全不知道这个对象是否是基于其它类。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE。但如果接着还有一个更晚派生类的构造函数被调用，那么这个构造函数又将设置VPTR指向它的VTABLE，以此类推，直到最后的构造函数结束。VRTP的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。</p>
<p>但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置VPTR指向它自己的VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的VTABLE的调用，而不是最后派生的VTABLE（所有构造函数被调用后才会有最后派生的VTABLE）。另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早绑定，因为它们知道晚绑定将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。</p>
<h2 id="静态函数可以是虚函数么为什么">
  静态函数可以是虚函数么？为什么？
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e6%98%af%e8%99%9a%e5%87%bd%e6%95%b0%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p>
<p>静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。所以无法访问vptr. 进而不能访问虚函数表。</p>
<h2 id="析构函数可以是纯虚函数么">
  析构函数可以是纯虚函数么？
  <a class="heading-link" href="#%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e6%98%af%e7%ba%af%e8%99%9a%e5%87%bd%e6%95%b0%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>是的，析构函数可以被声明为纯虚函数（pure virtual destructor）在C++中。这通常用于定义抽象基类（Abstract Base Class，ABC），即这样的类不打算被实例化，而是作为派生类的基础。声明纯虚析构函数的目的是确保基类有一个虚析构函数，允许通过基类指针正确地删除派生类的对象。</p>
<h3 id="纯虚析构函数">
  纯虚析构函数
  <a class="heading-link" href="#%e7%ba%af%e8%99%9a%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>当你将析构函数声明为纯虚函数时，你表明了类是抽象的，不能直接实例化，并且你期望从它派生出新的类。但与其他纯虚函数不同，纯虚析构函数必须提供一个定义，因为派生类的析构过程中会调用它。</p>
<h3 id="示例-2">
  示例
  <a class="heading-link" href="#%e7%a4%ba%e4%be%8b-2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractBase</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>AbstractBase() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 纯虚析构函数
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span>AbstractBase<span style="color:#f92672">::~</span>AbstractBase() {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span>    <span style="color:#75715e">// 必须提供实现，即使是空实现
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在这个示例中，<code>AbstractBase</code>有一个纯虚析构函数，使得<code>AbstractBase</code>成为一个抽象基类。尽管析构函数是纯虚的，我们仍然提供了它的定义，这是必须的。</p>
<h3 id="注意事项">
  注意事项
  <a class="heading-link" href="#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>即使类中有纯虚析构函数，这个类也需要提供析构函数的定义。这是因为当派生类被销毁时，析构函数的调用会沿着继承链向上进行，最终会调用到基类的析构函数。</li>
<li>如果一个类有纯虚析构函数，它可以没有其他的纯虚函数。但是，这样的类仍然是抽象类，不能直接实例化。</li>
<li>纯虚析构函数的存在不影响派生类的析构函数的实现。派生类应该提供自己的析构函数来确保正确的资源清理。派生类的析构函数会自动调用基类的析构函数。</li>
</ul>
<p>声明纯虚析构函数是一种表明类是为了被继承而设计，并且不应该直接实例化的方式。同时，它确保了派生类对象通过基类指针被正确销毁的能力，这对于避免内存泄漏等问题至关重要。</p>
<h2 id="定义一个a-pa-new-a5-delete-pa-类a的构造函数和析构函数分别执行了几次">
  定义一个A* pa= new A[5]; delete pa; 类A的构造函数和析构函数分别执行了几次？
  <a class="heading-link" href="#%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aaa-pa-new-a5-delete-pa-%e7%b1%bba%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e5%88%86%e5%88%ab%e6%89%a7%e8%a1%8c%e4%ba%86%e5%87%a0%e6%ac%a1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>构造函数执行了5次，每new一个对象都会调用一个构造函数，析构函数只调用一次，如果调用delete[] pa 析构函数才会调用5次。</p>
<h2 id="reserve和resize的区别是什么">
  reserve和resize的区别是什么？
  <a class="heading-link" href="#reserve%e5%92%8cresize%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="智能指针有几种分别介绍一下他们的底层实现">
  智能指针有几种？分别介绍一下他们的底层实现？
  <a class="heading-link" href="#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%e6%9c%89%e5%87%a0%e7%a7%8d%e5%88%86%e5%88%ab%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b%e4%bb%96%e4%bb%ac%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="为什么需要智能指针">
  为什么需要智能指针
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="你刚才说到循环引用那你口述一个循环引用的实例在你说的这个实例中那你怎么用weak_ptr来解决呢">
  你刚才说到循环引用，那你口述一个循环引用的实例。在你说的这个实例中，那你怎么用weak_ptr来解决呢？
  <a class="heading-link" href="#%e4%bd%a0%e5%88%9a%e6%89%8d%e8%af%b4%e5%88%b0%e5%be%aa%e7%8e%af%e5%bc%95%e7%94%a8%e9%82%a3%e4%bd%a0%e5%8f%a3%e8%bf%b0%e4%b8%80%e4%b8%aa%e5%be%aa%e7%8e%af%e5%bc%95%e7%94%a8%e7%9a%84%e5%ae%9e%e4%be%8b%e5%9c%a8%e4%bd%a0%e8%af%b4%e7%9a%84%e8%bf%99%e4%b8%aa%e5%ae%9e%e4%be%8b%e4%b8%ad%e9%82%a3%e4%bd%a0%e6%80%8e%e4%b9%88%e7%94%a8weak_ptr%e6%9d%a5%e8%a7%a3%e5%86%b3%e5%91%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="说一下lambda表达式的底层实现">
  说一下lambda表达式的底层实现
  <a class="heading-link" href="#%e8%af%b4%e4%b8%80%e4%b8%8blambda%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>C++中的lambda表达式在底层实现上可以被视为一个匿名类（或称为闭包类型）的实例。当编译器遇到lambda表达式时，它会生成一个与lambda行为相匹配的唯一的类类型，这个类会重载函数调用操作符<code>operator()</code>，使得该类的实例（对象）可以像函数那样被调用。这个自动生成的类通常被称为闭包类型，而生成的对象称为闭包对象。</p>
<h3 id="lambda表达式的组成">
  Lambda表达式的组成
  <a class="heading-link" href="#lambda%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e7%bb%84%e6%88%90">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>一个lambda表达式通常包含三个部分：捕获列表（capture list）、参数列表（parameter list）以及函数体（function body）。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">auto</span> lambda <span style="color:#f92672">=</span> [capture](parameters) <span style="color:#f92672">-&gt;</span> return_type { body };
</span></span></code></pre></div><h3 id="底层实现细节">
  底层实现细节
  <a class="heading-link" href="#%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>闭包类型的生成</strong>：对于每个lambda表达式，编译器生成一个唯一的未命名（匿名）类。这个类实现了<code>operator()</code>，使得其对象可以通过函数调用语法使用。</p>
</li>
<li>
<p><strong>捕获列表的处理</strong>：</p>
<ul>
<li><strong>值捕获（By Value）</strong>：被捕获的变量在闭包对象创建时通过拷贝初始化。每个被捕获的变量都会成为闭包类型的一个数据成员。</li>
<li><strong>引用捕获（By Reference）</strong>：通过引用捕获的变量不会被拷贝，相反，闭包对象存储的是变量的引用。</li>
<li><strong>隐式捕获</strong>：编译器根据lambda表达式体中使用的外部变量自动生成捕获列表。</li>
</ul>
</li>
<li>
<p><strong>构造函数</strong>：闭包类型会有一个构造函数，用于初始化闭包对象中的数据成员。这个构造函数根据捕获列表来定义。</p>
</li>
<li>
<p><strong><code>operator()</code>的实现</strong>：闭包类型重载的<code>operator()</code>会包含lambda表达式的函数体作为其实现。这个重载允许闭包对象像函数那样被调用。</p>
</li>
</ol>
<h3 id="例子">
  例子
  <a class="heading-link" href="#%e4%be%8b%e5%ad%90">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>考虑下面的lambda表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">auto</span> lambda <span style="color:#f92672">=</span> [x](<span style="color:#66d9ef">int</span> y) { <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y; };
</span></span></code></pre></div><p>编译器会为这个lambda生成类似于以下伪代码的闭包类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UniqueClosure</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>    <span style="color:#66d9ef">int</span> captured_x;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>    UniqueClosure(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> captured_x(x) {}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span> y) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span>        <span style="color:#66d9ef">return</span> captured_x <span style="color:#f92672">+</span> y;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span>};
</span></span></code></pre></div><p>然后，<code>lambda</code>变量实际上是<code>UniqueClosure</code>类型的一个实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>UniqueClosure <span style="color:#a6e22e">lambda</span>(x);
</span></span></code></pre></div><h3 id="总结-4">
  总结
  <a class="heading-link" href="#%e6%80%bb%e7%bb%93-4">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>C++中的lambda表达式底层通过生成一个特殊的闭包类型来实现，这个类型重载了函数调用操作符并存储了所有必要的捕获变量，使得lambda表达式既可以捕获周围的上下文，也可以像普通函数那样被调用。这个过程完全由编译器自动完成，对程序员透明。</p>
<h2 id="深拷贝和浅拷贝的区别">
  深拷贝和浅拷贝的区别
  <a class="heading-link" href="#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="讲一下四种类型转换符">
  讲一下四种类型转换符？
  <a class="heading-link" href="#%e8%ae%b2%e4%b8%80%e4%b8%8b%e5%9b%9b%e7%a7%8d%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e7%ac%a6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="进程间通信">
  进程间通信
  <a class="heading-link" href="#%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="线程间通信">
  线程间通信
  <a class="heading-link" href="#%e7%ba%bf%e7%a8%8b%e9%97%b4%e9%80%9a%e4%bf%a1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="协程是什么">
  协程是什么？
  <a class="heading-link" href="#%e5%8d%8f%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="用户态和内核态区别">
  用户态和内核态区别
  <a class="heading-link" href="#%e7%94%a8%e6%88%b7%e6%80%81%e5%92%8c%e5%86%85%e6%a0%b8%e6%80%81%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="死锁产生的原因及四个必要条件">
  死锁产生的原因及四个必要条件
  <a class="heading-link" href="#%e6%ad%bb%e9%94%81%e4%ba%a7%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0%e5%8f%8a%e5%9b%9b%e4%b8%aa%e5%bf%85%e8%a6%81%e6%9d%a1%e4%bb%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="系统调用是什么有哪些系统调用">
  系统调用是什么，有哪些系统调用
  <a class="heading-link" href="#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e5%93%aa%e4%ba%9b%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="孤儿进程僵尸进程">
  孤儿进程、僵尸进程
  <a class="heading-link" href="#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="单核机器上写多线程程序是否需要考虑加锁为什么">
  单核机器上写多线程程序，是否需要考虑加锁，为什么？
  <a class="heading-link" href="#%e5%8d%95%e6%a0%b8%e6%9c%ba%e5%99%a8%e4%b8%8a%e5%86%99%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%a8%8b%e5%ba%8f%e6%98%af%e5%90%a6%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e5%8a%a0%e9%94%81%e4%b8%ba%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="静态链接和动态链接">
  静态链接和动态链接
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%92%8c%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="硬链接和软链接">
  硬链接和软链接
  <a class="heading-link" href="#%e7%a1%ac%e9%93%be%e6%8e%a5%e5%92%8c%e8%bd%af%e9%93%be%e6%8e%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="为什么是成倍扩容而不是等差扩容">
  为什么是成倍扩容，而不是等差扩容
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e6%88%90%e5%80%8d%e6%89%a9%e5%ae%b9%e8%80%8c%e4%b8%8d%e6%98%af%e7%ad%89%e5%b7%ae%e6%89%a9%e5%ae%b9">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="-范围解析运算符有哪些用法">
  :: 范围解析运算符有哪些用法
  <a class="heading-link" href="#-%e8%8c%83%e5%9b%b4%e8%a7%a3%e6%9e%90%e8%bf%90%e7%ae%97%e7%ac%a6%e6%9c%89%e5%93%aa%e4%ba%9b%e7%94%a8%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="inline关键字">
  inline关键字
  <a class="heading-link" href="#inline%e5%85%b3%e9%94%ae%e5%ad%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="union关键字">
  union关键字
  <a class="heading-link" href="#union%e5%85%b3%e9%94%ae%e5%ad%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="using关键字用法">
  using关键字用法
  <a class="heading-link" href="#using%e5%85%b3%e9%94%ae%e5%ad%97%e7%94%a8%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="friend关键字">
  friend关键字
  <a class="heading-link" href="#friend%e5%85%b3%e9%94%ae%e5%ad%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="volatile关键字">
  volatile关键字
  <a class="heading-link" href="#volatile%e5%85%b3%e9%94%ae%e5%ad%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="为避免对同一对象进行赋值操作this指针用法">
  为避免对同一对象进行赋值操作，this指针，用法
  <a class="heading-link" href="#%e4%b8%ba%e9%81%bf%e5%85%8d%e5%af%b9%e5%90%8c%e4%b8%80%e5%af%b9%e8%b1%a1%e8%bf%9b%e8%a1%8c%e8%b5%8b%e5%80%bc%e6%93%8d%e4%bd%9cthis%e6%8c%87%e9%92%88%e7%94%a8%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++中，<code>this</code>指针是一个特殊的指针，它指向当前对象。使用<code>this</code>指针的一个常见场景是在成员函数中，特别是在赋值操作符<code>operator=</code>的重载函数中，来避免自赋值的情况。自赋值发生在一个对象被赋值给自身的时候，如果不进行检测，这可能导致意想不到的错误，尤其是在涉及动态内存分配的时候。</p>
<p>下面是如何使用<code>this</code>指针来避免自赋值的一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>    MyClass<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> MyClass<span style="color:#f92672">&amp;</span> other) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>        <span style="color:#75715e">// 检查自赋值
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> <span style="color:#f92672">&amp;</span>other) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>            <span style="color:#75715e">// 是自赋值，直接返回*this
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>        <span style="color:#75715e">// 不是自赋值，执行赋值操作
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 例如，释放当前对象持有的资源
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span><span style="color:#75715e"></span>        <span style="color:#75715e">//delete[] this-&gt;data;
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>        <span style="color:#75715e">// 然后复制other的数据到当前对象
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span><span style="color:#75715e"></span>        <span style="color:#75715e">//this-&gt;data = new int[...];
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span><span style="color:#75715e"></span>        <span style="color:#75715e">//std::copy(...);
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; <span style="color:#75715e">// 返回当前对象的引用
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>};
</span></span></code></pre></div><h3 id="自赋值检查的工作原理">
  自赋值检查的工作原理
  <a class="heading-link" href="#%e8%87%aa%e8%b5%8b%e5%80%bc%e6%a3%80%e6%9f%a5%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>比较<code>this</code>和<code>&amp;other</code></strong>：通过比较当前对象的<code>this</code>指针和赋值右侧对象的地址<code>&amp;other</code>，可以检查赋值操作是否试图将对象赋值给自身。</li>
<li><strong>提前返回</strong>：如果检测到自赋值，函数直接返回<code>*this</code>，避免执行无意义或可能危险的资源释放和重新分配操作。</li>
<li><strong>正常赋值流程</strong>：如果不是自赋值，函数则继续执行正常的赋值逻辑，如释放旧资源，分配新资源，复制数据等。</li>
</ul>
<h3 id="为什么要避免自赋值">
  为什么要避免自赋值
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%81%bf%e5%85%8d%e8%87%aa%e8%b5%8b%e5%80%bc">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>在某些情况下，如果不检查自赋值，赋值操作可能会破坏对象的状态。例如，如果赋值操作首先释放了对象持有的资源，然后试图从自身复制这些资源，那么在释放资源之后，对象将尝试从已经被释放的资源复制数据，这将导致未定义行为。</p>
<p>通过在赋值操作中添加自赋值检查，可以保证即使在自赋值的情况下，对象的状态也能保持一致和安全。这是一个良好的编程实践，特别是在处理涉及动态内存管理的复杂类时。</p>
<h2 id="什么是copy-on-write">
  什么是copy on write
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%afcopy-on-write">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="模板特化与偏特化">
  模板特化与偏特化
  <a class="heading-link" href="#%e6%a8%a1%e6%9d%bf%e7%89%b9%e5%8c%96%e4%b8%8e%e5%81%8f%e7%89%b9%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>在C++模板编程中，模板特化和偏特化是两种重要的技术，它们允许程序员为模板提供特定类型的实现。虽然它们的目的相似，即为某些特定情况提供定制的模板代码，但它们在使用和概念上有着明显的区别。</p>
<h3 id="模板特化template-specialization">
  模板特化（Template Specialization）
  <a class="heading-link" href="#%e6%a8%a1%e6%9d%bf%e7%89%b9%e5%8c%96template-specialization">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>模板特化是指为模板的一个具体类型或类型组合提供一个特定的实现。当模板参数满足特化条件时，编译器会使用特化的实现而不是通用模板。模板特化可以应用于函数模板和类模板。</p>
<h4 id="全特化full-specialization">
  全特化（Full Specialization）
  <a class="heading-link" href="#%e5%85%a8%e7%89%b9%e5%8c%96full-specialization">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>当为模板的所有参数提供特定的类型时，称之为全特化。</p>
<p><strong>类模板全特化示例：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyTemplate</span> { <span style="color:#75715e">/* 通用实现 */</span> };
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#75715e">// 全特化为int类型
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyTemplate</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> { <span style="color:#75715e">/* 特化实现 */</span> };
</span></span></code></pre></div><p><strong>函数模板全特化示例：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">void</span> myFunction(T value) { <span style="color:#75715e">/* 通用实现 */</span> }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#75715e">// 全特化为int类型
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span><span style="color:#66d9ef">void</span> myFunction<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">int</span> value) { <span style="color:#75715e">/* 特化实现 */</span> }
</span></span></code></pre></div><h3 id="模板偏特化partial-specialization">
  模板偏特化（Partial Specialization）
  <a class="heading-link" href="#%e6%a8%a1%e6%9d%bf%e5%81%8f%e7%89%b9%e5%8c%96partial-specialization">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>模板偏特化是类模板的一种特殊形式，它允许为模板的一部分参数提供特定的类型，而不是全部参数。注意，函数模板不支持偏特化，偏特化仅适用于类模板。</p>
<p><strong>类模板偏特化示例：</strong></p>
<p>假设我们有一个模板用于处理指针，我们可以为指针类型提供一个偏特化版本：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyTemplate</span> { <span style="color:#75715e">/* 通用实现 */</span> };
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span><span style="color:#75715e">// 偏特化为指针类型
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyTemplate</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> { <span style="color:#75715e">/* 指针类型的特化实现 */</span> };
</span></span></code></pre></div><p>在这个例子中，当<code>MyTemplate</code>的模板参数是任何类型的指针时，会使用偏特化版本。</p>
<h3 id="区别总结">
  区别总结
  <a class="heading-link" href="#%e5%8c%ba%e5%88%ab%e6%80%bb%e7%bb%93">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li><strong>全特化</strong>：为模板提供一个针对特定类型或类型组合的完全定制的实现。适用于函数模板和类模板。</li>
<li><strong>偏特化</strong>：只针对类模板，允许为模板的一部分参数提供特定的类型。它是对模板的进一步泛化，用于处理更具体的情况，但不像全特化那样针对全部参数。</li>
</ul>
<p>模板特化和偏特化是C++模板编程中强大的特性，允许开发者根据不同的类型参数定制模板的行为，提高了代码的灵活性和可重用性。</p>
<h2 id="为什么函数模板不支持偏特化">
  为什么函数模板不支持偏特化
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e4%b8%8d%e6%94%af%e6%8c%81%e5%81%8f%e7%89%b9%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="写一个宏版本的min">
  写一个宏版本的MIN
  <a class="heading-link" href="#%e5%86%99%e4%b8%80%e4%b8%aa%e5%ae%8f%e7%89%88%e6%9c%ac%e7%9a%84min">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="auto作为返回值和模板一起怎么用">
  auto作为返回值和模板一起怎么用
  <a class="heading-link" href="#auto%e4%bd%9c%e4%b8%ba%e8%bf%94%e5%9b%9e%e5%80%bc%e5%92%8c%e6%a8%a1%e6%9d%bf%e4%b8%80%e8%b5%b7%e6%80%8e%e4%b9%88%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="tcp和udp区别">
  TCP和UDP区别
  <a class="heading-link" href="#tcp%e5%92%8cudp%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="c-类对象的初始化顺序有多重继承情况下的顺序">
  C++ 类对象的初始化顺序，有多重继承情况下的顺序
  <a class="heading-link" href="#c-%e7%b1%bb%e5%af%b9%e8%b1%a1%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f%e6%9c%89%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf%e6%83%85%e5%86%b5%e4%b8%8b%e7%9a%84%e9%a1%ba%e5%ba%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="如果三次握手时候每次握手信息对方没收到会怎么样简答">
  如果三次握手时候每次握手信息对方没收到会怎么样，简答
  <a class="heading-link" href="#%e5%a6%82%e6%9e%9c%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e6%97%b6%e5%80%99%e6%af%8f%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bf%a1%e6%81%af%e5%af%b9%e6%96%b9%e6%b2%a1%e6%94%b6%e5%88%b0%e4%bc%9a%e6%80%8e%e4%b9%88%e6%a0%b7%e7%ae%80%e7%ad%94">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="avl-和红黑树的差别">
  AVL 和红黑树的差别
  <a class="heading-link" href="#avl-%e5%92%8c%e7%ba%a2%e9%bb%91%e6%a0%91%e7%9a%84%e5%b7%ae%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数据库事务的特点">
  数据库事务的特点
  <a class="heading-link" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e7%82%b9">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="虚拟地址如何转为物理地址">
  虚拟地址如何转为物理地址
  <a class="heading-link" href="#%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e5%a6%82%e4%bd%95%e8%bd%ac%e4%b8%ba%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="说一下滑动窗口如果接收方滑动窗口满了发送方会怎么做">
  说一下滑动窗口，如果接收方滑动窗口满了，发送方会怎么做
  <a class="heading-link" href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%a6%82%e6%9e%9c%e6%8e%a5%e6%94%b6%e6%96%b9%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%bb%a1%e4%ba%86%e5%8f%91%e9%80%81%e6%96%b9%e4%bc%9a%e6%80%8e%e4%b9%88%e5%81%9a">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="页面置换算法">
  页面置换算法
  <a class="heading-link" href="#%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="既然有了mallocfreec中为什么还需要newdelete呢">
  既然有了malloc/free，C++中为什么还需要new/delete呢？
  <a class="heading-link" href="#%e6%97%a2%e7%84%b6%e6%9c%89%e4%ba%86mallocfreec%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e9%9c%80%e8%a6%81newdelete%e5%91%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="delete怎么实现">
  delete[]怎么实现
  <a class="heading-link" href="#delete%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="计算类的sizeof">
  计算类的sizeof
  <a class="heading-link" href="#%e8%ae%a1%e7%ae%97%e7%b1%bb%e7%9a%84sizeof">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="解决哈希冲突的方式">
  解决哈希冲突的方式？
  <a class="heading-link" href="#%e8%a7%a3%e5%86%b3%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81%e7%9a%84%e6%96%b9%e5%bc%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="结构体内存对齐方式和为什么要进行内存对齐">
  结构体内存对齐方式和为什么要进行内存对齐？
  <a class="heading-link" href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90%e6%96%b9%e5%bc%8f%e5%92%8c%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%bf%9b%e8%a1%8c%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="调试程序的方法">
  调试程序的方法
  <a class="heading-link" href="#%e8%b0%83%e8%af%95%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="遇到coredump要怎么调试">
  遇到coredump要怎么调试
  <a class="heading-link" href="#%e9%81%87%e5%88%b0coredump%e8%a6%81%e6%80%8e%e4%b9%88%e8%b0%83%e8%af%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="成员初始化列表的概念为什么用成员初始化列表会快一些性能优势">
  成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？
  <a class="heading-link" href="#%e6%88%90%e5%91%98%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8%e7%9a%84%e6%a6%82%e5%bf%b5%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%a8%e6%88%90%e5%91%98%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8%e4%bc%9a%e5%bf%ab%e4%b8%80%e4%ba%9b%e6%80%a7%e8%83%bd%e4%bc%98%e5%8a%bf">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="有三种情况是必须使用成员初始化列表进行初始化">
  有三种情况是必须使用成员初始化列表进行初始化
  <a class="heading-link" href="#%e6%9c%89%e4%b8%89%e7%a7%8d%e6%83%85%e5%86%b5%e6%98%af%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8%e6%88%90%e5%91%98%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8%e8%bf%9b%e8%a1%8c%e5%88%9d%e5%a7%8b%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>常量成员的初始化，因为常量成员只能初始化不能赋值
引用类型
没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</p>
<p>见：<a href="https://www.nowcoder.com/discuss/353156833760190464#:~:text=%E8%AF%A6%E8%A7%81-,C%2B%2B%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8,-%EF%BC%8845%EF%BC%89%20%E7%94%A8%E8%BF%87"  class="external-link" target="_blank" rel="noopener">C++ 初始化列表</a></p>
<h2 id="c的调用惯例简单一点c函数调用的压栈过程">
  C++的调用惯例（简单一点C++函数调用的压栈过程）
  <a class="heading-link" href="#c%e7%9a%84%e8%b0%83%e7%94%a8%e6%83%af%e4%be%8b%e7%ae%80%e5%8d%95%e4%b8%80%e7%82%b9c%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e7%9a%84%e5%8e%8b%e6%a0%88%e8%bf%87%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="一个函数或者可执行文件的生成过程或者编译过程是怎样的">
  一个函数或者可执行文件的生成过程或者编译过程是怎样的
  <a class="heading-link" href="#%e4%b8%80%e4%b8%aa%e5%87%bd%e6%95%b0%e6%88%96%e8%80%85%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6%e7%9a%84%e7%94%9f%e6%88%90%e8%bf%87%e7%a8%8b%e6%88%96%e8%80%85%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="定义和声明的区别">
  定义和声明的区别
  <a class="heading-link" href="#%e5%ae%9a%e4%b9%89%e5%92%8c%e5%a3%b0%e6%98%8e%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="被free回收的内存是立即返还给操作系统吗为什么">
  被free回收的内存是立即返还给操作系统吗？为什么
  <a class="heading-link" href="#%e8%a2%abfree%e5%9b%9e%e6%94%b6%e7%9a%84%e5%86%85%e5%ad%98%e6%98%af%e7%ab%8b%e5%8d%b3%e8%bf%94%e8%bf%98%e7%bb%99%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%90%97%e4%b8%ba%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="引用作为函数参数以及返回值的好处">
  引用作为函数参数以及返回值的好处
  <a class="heading-link" href="#%e5%bc%95%e7%94%a8%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0%e4%bb%a5%e5%8f%8a%e8%bf%94%e5%9b%9e%e5%80%bc%e7%9a%84%e5%a5%bd%e5%a4%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="建立tcp服务器的各个系统调用">
  建立TCP服务器的各个系统调用
  <a class="heading-link" href="#%e5%bb%ba%e7%ab%8btcp%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e5%90%84%e4%b8%aa%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="tcp和udp相关的协议与端口号">
  TCP和UDP相关的协议与端口号
  <a class="heading-link" href="#tcp%e5%92%8cudp%e7%9b%b8%e5%85%b3%e7%9a%84%e5%8d%8f%e8%ae%ae%e4%b8%8e%e7%ab%af%e5%8f%a3%e5%8f%b7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="http的请求方法有哪些get和post的区别">
  http的请求方法有哪些？get和post的区别。
  <a class="heading-link" href="#http%e7%9a%84%e8%af%b7%e6%b1%82%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9bget%e5%92%8cpost%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="tcp三次握手时的第一次的seq序号是怎样产生的">
  TCP三次握手时的第一次的seq序号是怎样产生的
  <a class="heading-link" href="#tcp%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e6%97%b6%e7%9a%84%e7%ac%ac%e4%b8%80%e6%ac%a1%e7%9a%84seq%e5%ba%8f%e5%8f%b7%e6%98%af%e6%80%8e%e6%a0%b7%e4%ba%a7%e7%94%9f%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="一个机器能够使用的端口号上限是多少为什么可以改变吗那如果想要用的端口超过这个限制怎么办">
  一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？
  <a class="heading-link" href="#%e4%b8%80%e4%b8%aa%e6%9c%ba%e5%99%a8%e8%83%bd%e5%a4%9f%e4%bd%bf%e7%94%a8%e7%9a%84%e7%ab%af%e5%8f%a3%e5%8f%b7%e4%b8%8a%e9%99%90%e6%98%af%e5%a4%9a%e5%b0%91%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%af%e4%bb%a5%e6%94%b9%e5%8f%98%e5%90%97%e9%82%a3%e5%a6%82%e6%9e%9c%e6%83%b3%e8%a6%81%e7%94%a8%e7%9a%84%e7%ab%af%e5%8f%a3%e8%b6%85%e8%bf%87%e8%bf%99%e4%b8%aa%e9%99%90%e5%88%b6%e6%80%8e%e4%b9%88%e5%8a%9e">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="对称密码和非对称密码体系">
  对称密码和非对称密码体系
  <a class="heading-link" href="#%e5%af%b9%e7%a7%b0%e5%af%86%e7%a0%81%e5%92%8c%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%af%86%e7%a0%81%e4%bd%93%e7%b3%bb">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数字证书是什么">
  数字证书是什么？
  <a class="heading-link" href="#%e6%95%b0%e5%ad%97%e8%af%81%e4%b9%a6%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="服务器出现大量close_wait的连接的原因以及解决方法">
  服务器出现大量close_wait的连接的原因以及解决方法
  <a class="heading-link" href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%87%ba%e7%8e%b0%e5%a4%a7%e9%87%8fclose_wait%e7%9a%84%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%8e%9f%e5%9b%a0%e4%bb%a5%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="消息摘要算法列举一下介绍md5算法为什么md5是不可逆的有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢">
  消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？
  <a class="heading-link" href="#%e6%b6%88%e6%81%af%e6%91%98%e8%a6%81%e7%ae%97%e6%b3%95%e5%88%97%e4%b8%be%e4%b8%80%e4%b8%8b%e4%bb%8b%e7%bb%8dmd5%e7%ae%97%e6%b3%95%e4%b8%ba%e4%bb%80%e4%b9%88md5%e6%98%af%e4%b8%8d%e5%8f%af%e9%80%86%e7%9a%84%e6%9c%89%e4%bb%80%e4%b9%88%e5%8a%9e%e6%b3%95%e5%8f%af%e4%bb%a5%e5%8a%a0%e5%bc%ba%e6%b6%88%e6%81%af%e6%91%98%e8%a6%81%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7%e8%ae%a9%e5%ae%83%e4%b8%8d%e9%82%a3%e4%b9%88%e5%ae%b9%e6%98%93%e8%a2%ab%e7%a0%b4%e8%a7%a3%e5%91%a2">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="介绍一下ping的过程分别用到了哪些协议">
  介绍一下ping的过程，分别用到了哪些协议
  <a class="heading-link" href="#%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bping%e7%9a%84%e8%bf%87%e7%a8%8b%e5%88%86%e5%88%ab%e7%94%a8%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e5%8d%8f%e8%ae%ae">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="tcpip的粘包与避免介绍一下">
  TCP/IP的粘包与避免介绍一下
  <a class="heading-link" href="#tcpip%e7%9a%84%e7%b2%98%e5%8c%85%e4%b8%8e%e9%81%bf%e5%85%8d%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="一个ip配置多个域名靠什么识别">
  一个ip配置多个域名，靠什么识别？
  <a class="heading-link" href="#%e4%b8%80%e4%b8%aaip%e9%85%8d%e7%bd%ae%e5%a4%9a%e4%b8%aa%e5%9f%9f%e5%90%8d%e9%9d%a0%e4%bb%80%e4%b9%88%e8%af%86%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="dns的工作过程和原理">
  DNS的工作过程和原理
  <a class="heading-link" href="#dns%e7%9a%84%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b%e5%92%8c%e5%8e%9f%e7%90%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="arp协议">
  ARP协议
  <a class="heading-link" href="#arp%e5%8d%8f%e8%ae%ae">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="关系型和非关系型数据库的区别">
  关系型和非关系型数据库的区别
  <a class="heading-link" href="#%e5%85%b3%e7%b3%bb%e5%9e%8b%e5%92%8c%e9%9d%9e%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="说一下-mysql-执行一条查询语句的内部执行过程">
  说一下 MySQL 执行一条查询语句的内部执行过程？
  <a class="heading-link" href="#%e8%af%b4%e4%b8%80%e4%b8%8b-mysql-%e6%89%a7%e8%a1%8c%e4%b8%80%e6%9d%a1%e6%9f%a5%e8%af%a2%e8%af%ad%e5%8f%a5%e7%9a%84%e5%86%85%e9%83%a8%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数据库的索引类型有哪些">
  数据库的索引类型有哪些
  <a class="heading-link" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="说一下事务是怎么实现的">
  说一下事务是怎么实现的
  <a class="heading-link" href="#%e8%af%b4%e4%b8%80%e4%b8%8b%e4%ba%8b%e5%8a%a1%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="mysql怎么建立索引怎么建立主键索引怎么删除索引">
  MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？
  <a class="heading-link" href="#mysql%e6%80%8e%e4%b9%88%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95%e6%80%8e%e4%b9%88%e5%bb%ba%e7%ab%8b%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e6%80%8e%e4%b9%88%e5%88%a0%e9%99%a4%e7%b4%a2%e5%bc%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="索引的优缺点什么时候使用索引什么时候不能使用索引">
  索引的优缺点，什么时候使用索引，什么时候不能使用索引
  <a class="heading-link" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%b8%8d%e8%83%bd%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="索引的底层实现">
  索引的底层实现
  <a class="heading-link" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="b树和b树的区别">
  B树和B+树的区别
  <a class="heading-link" href="#b%e6%a0%91%e5%92%8cb%e6%a0%91%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="mysql的优化">
  Mysql的优化
  <a class="heading-link" href="#mysql%e7%9a%84%e4%bc%98%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="高频访问">
  高频访问
  <a class="heading-link" href="#%e9%ab%98%e9%a2%91%e8%ae%bf%e9%97%ae">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h3 id="并发优化">
  并发优化
  <a class="heading-link" href="#%e5%b9%b6%e5%8f%91%e4%bc%98%e5%8c%96">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h2 id="索引最左前缀最左匹配">
  索引最左前缀/最左匹配
  <a class="heading-link" href="#%e7%b4%a2%e5%bc%95%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e6%9c%80%e5%b7%a6%e5%8c%b9%e9%85%8d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数据库中事务的acid">
  数据库中事务的ACID
  <a class="heading-link" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e4%ba%8b%e5%8a%a1%e7%9a%84acid">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="什么是脏读不可重复读和幻读">
  什么是脏读，不可重复读和幻读？
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%84%8f%e8%af%bb%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e5%92%8c%e5%b9%bb%e8%af%bb">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数据库的隔离级别mysql和oracle的隔离级别分别是什么">
  数据库的隔离级别，mysql和Oracle的隔离级别分别是什么
  <a class="heading-link" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%abmysql%e5%92%8coracle%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="mysql的表空间方式各自特点">
  Mysql的表空间方式，各自特点
  <a class="heading-link" href="#mysql%e7%9a%84%e8%a1%a8%e7%a9%ba%e9%97%b4%e6%96%b9%e5%bc%8f%e5%90%84%e8%87%aa%e7%89%b9%e7%82%b9">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数据库的范式">
  数据库的范式
  <a class="heading-link" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%8c%83%e5%bc%8f">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="乐观锁与悲观锁解释一下">
  乐观锁与悲观锁解释一下
  <a class="heading-link" href="#%e4%b9%90%e8%a7%82%e9%94%81%e4%b8%8e%e6%82%b2%e8%a7%82%e9%94%81%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="乐观锁与悲观锁是怎么实现的">
  乐观锁与悲观锁是怎么实现的
  <a class="heading-link" href="#%e4%b9%90%e8%a7%82%e9%94%81%e4%b8%8e%e6%82%b2%e8%a7%82%e9%94%81%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="linux的io模型介绍以及同步异步阻塞非阻塞的区别">
  Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别
  <a class="heading-link" href="#linux%e7%9a%84io%e6%a8%a1%e5%9e%8b%e4%bb%8b%e7%bb%8d%e4%bb%a5%e5%8f%8a%e5%90%8c%e6%ad%a5%e5%bc%82%e6%ad%a5%e9%98%bb%e5%a1%9e%e9%9d%9e%e9%98%bb%e5%a1%9e%e7%9a%84%e5%8c%ba%e5%88%ab">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="文件系统的理解ext4xfsbtrfs">
  文件系统的理解（EXT4，XFS，BTRFS）
  <a class="heading-link" href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%90%86%e8%a7%a3ext4xfsbtrfs">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="什么是io多路复用">
  什么是IO多路复用
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%afio%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="io复用的三种方法selectpollepoll深入理解包括三者区别内部原理实现">
  IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？
  <a class="heading-link" href="#io%e5%a4%8d%e7%94%a8%e7%9a%84%e4%b8%89%e7%a7%8d%e6%96%b9%e6%b3%95selectpollepoll%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e5%8c%85%e6%8b%ac%e4%b8%89%e8%80%85%e5%8c%ba%e5%88%ab%e5%86%85%e9%83%a8%e5%8e%9f%e7%90%86%e5%ae%9e%e7%8e%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="epoll的et模式和lt模式et的非阻塞">
  Epoll的ET模式和LT模式（ET的非阻塞）
  <a class="heading-link" href="#epoll%e7%9a%84et%e6%a8%a1%e5%bc%8f%e5%92%8clt%e6%a8%a1%e5%bc%8fet%e7%9a%84%e9%9d%9e%e9%98%bb%e5%a1%9e">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="文件权限怎么看rwx">
  文件权限怎么看（rwx）
  <a class="heading-link" href="#%e6%96%87%e4%bb%b6%e6%9d%83%e9%99%90%e6%80%8e%e4%b9%88%e7%9c%8brwx">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="文件的三种时间mtime-atimectime分别在什么时候会改变">
  文件的三种时间（mtime, atime，ctime），分别在什么时候会改变
  <a class="heading-link" href="#%e6%96%87%e4%bb%b6%e7%9a%84%e4%b8%89%e7%a7%8d%e6%97%b6%e9%97%b4mtime-atimectime%e5%88%86%e5%88%ab%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bc%9a%e6%94%b9%e5%8f%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="linux监控网络带宽的命令查看特定进程的占用网络资源情况命令">
  Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令
  <a class="heading-link" href="#linux%e7%9b%91%e6%8e%a7%e7%bd%91%e7%bb%9c%e5%b8%a6%e5%ae%bd%e7%9a%84%e5%91%bd%e4%bb%a4%e6%9f%a5%e7%9c%8b%e7%89%b9%e5%ae%9a%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%8d%a0%e7%94%a8%e7%bd%91%e7%bb%9c%e8%b5%84%e6%ba%90%e6%83%85%e5%86%b5%e5%91%bd%e4%bb%a4">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="怎么修改一个文件的权限">
  怎么修改一个文件的权限
  <a class="heading-link" href="#%e6%80%8e%e4%b9%88%e4%bf%ae%e6%94%b9%e4%b8%80%e4%b8%aa%e6%96%87%e4%bb%b6%e7%9a%84%e6%9d%83%e9%99%90">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="coredump是什么-怎么才能coredump">
  coredump是什么 怎么才能coredump
  <a class="heading-link" href="#coredump%e6%98%af%e4%bb%80%e4%b9%88-%e6%80%8e%e4%b9%88%e6%89%8d%e8%83%bdcoredump">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="linux理论上最多可以创建多少个进程一个进程可以创建多少线程和什么有关">
  Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关
  <a class="heading-link" href="#linux%e7%90%86%e8%ae%ba%e4%b8%8a%e6%9c%80%e5%a4%9a%e5%8f%af%e4%bb%a5%e5%88%9b%e5%bb%ba%e5%a4%9a%e5%b0%91%e4%b8%aa%e8%bf%9b%e7%a8%8b%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%8f%af%e4%bb%a5%e5%88%9b%e5%bb%ba%e5%a4%9a%e5%b0%91%e7%ba%bf%e7%a8%8b%e5%92%8c%e4%bb%80%e4%b9%88%e6%9c%89%e5%85%b3">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="冯诺依曼结构有哪几个模块分别对应现代计算机的哪几个部分">
  冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？
  <a class="heading-link" href="#%e5%86%af%e8%af%ba%e4%be%9d%e6%9b%bc%e7%bb%93%e6%9e%84%e6%9c%89%e5%93%aa%e5%87%a0%e4%b8%aa%e6%a8%a1%e5%9d%97%e5%88%86%e5%88%ab%e5%af%b9%e5%ba%94%e7%8e%b0%e4%bb%a3%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%9a%84%e5%93%aa%e5%87%a0%e4%b8%aa%e9%83%a8%e5%88%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="进程之间的通信方法有哪几种">
  进程之间的通信方法有哪几种
  <a class="heading-link" href="#%e8%bf%9b%e7%a8%8b%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="进程调度方法详细介绍">
  进程调度方法详细介绍
  <a class="heading-link" href="#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e6%96%b9%e6%b3%95%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="什么是饥饿">
  什么是饥饿
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%a5%a5%e9%a5%bf">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="可重入函数是什么">
  可重入函数是什么
  <a class="heading-link" href="#%e5%8f%af%e9%87%8d%e5%85%a5%e5%87%bd%e6%95%b0%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="内核空间和用户空间是怎样区分的">
  内核空间和用户空间是怎样区分的
  <a class="heading-link" href="#%e5%86%85%e6%a0%b8%e7%a9%ba%e9%97%b4%e5%92%8c%e7%94%a8%e6%88%b7%e7%a9%ba%e9%97%b4%e6%98%af%e6%80%8e%e6%a0%b7%e5%8c%ba%e5%88%86%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="同一个进程内的线程会共享什么资源">
  同一个进程内的线程会共享什么资源？
  <a class="heading-link" href="#%e5%90%8c%e4%b8%80%e4%b8%aa%e8%bf%9b%e7%a8%8b%e5%86%85%e7%9a%84%e7%ba%bf%e7%a8%8b%e4%bc%9a%e5%85%b1%e4%ba%ab%e4%bb%80%e4%b9%88%e8%b5%84%e6%ba%90">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="brk和mmap是什么">
  brk和mmap是什么
  <a class="heading-link" href="#brk%e5%92%8cmmap%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="什么是字节序怎么判断是大端还是小端有什么用">
  什么是字节序？怎么判断是大端还是小端？有什么用？
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ad%97%e8%8a%82%e5%ba%8f%e6%80%8e%e4%b9%88%e5%88%a4%e6%96%ad%e6%98%af%e5%a4%a7%e7%ab%af%e8%bf%98%e6%98%af%e5%b0%8f%e7%ab%af%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="写单例模式线程安全版本">
  写单例模式，线程安全版本
  <a class="heading-link" href="#%e5%86%99%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%89%88%e6%9c%ac">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="写三个线程交替打印abc">
  写三个线程交替打印ABC
  <a class="heading-link" href="#%e5%86%99%e4%b8%89%e4%b8%aa%e7%ba%bf%e7%a8%8b%e4%ba%a4%e6%9b%bf%e6%89%93%e5%8d%b0abc">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="二维码登录的实现过程">
  二维码登录的实现过程
  <a class="heading-link" href="#%e4%ba%8c%e7%bb%b4%e7%a0%81%e7%99%bb%e5%bd%95%e7%9a%84%e5%ae%9e%e7%8e%b0%e8%bf%87%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="不使用临时变量实现swap函数">
  不使用临时变量实现swap函数
  <a class="heading-link" href="#%e4%b8%8d%e4%bd%bf%e7%94%a8%e4%b8%b4%e6%97%b6%e5%8f%98%e9%87%8f%e5%ae%9e%e7%8e%b0swap%e5%87%bd%e6%95%b0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="找到数组里第k大的数字">
  找到数组里第k大的数字
  <a class="heading-link" href="#%e6%89%be%e5%88%b0%e6%95%b0%e7%bb%84%e9%87%8c%e7%ac%ack%e5%a4%a7%e7%9a%84%e6%95%b0%e5%ad%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="top-k问题">
  Top K问题
  <a class="heading-link" href="#top-k%e9%97%ae%e9%a2%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="b树-b树">
  B树 B+树
  <a class="heading-link" href="#b%e6%a0%91-b%e6%a0%91">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="怎么写sql取表的前1000行数据">
  怎么写sql取表的前1000行数据
  <a class="heading-link" href="#%e6%80%8e%e4%b9%88%e5%86%99sql%e5%8f%96%e8%a1%a8%e7%9a%84%e5%89%8d1000%e8%a1%8c%e6%95%b0%e6%8d%ae">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="布隆过滤器">
  布隆过滤器
  <a class="heading-link" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="实现一个队列并且使它支持多线程">
  实现一个队列，并且使它支持多线程
  <a class="heading-link" href="#%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e9%98%9f%e5%88%97%e5%b9%b6%e4%b8%94%e4%bd%bf%e5%ae%83%e6%94%af%e6%8c%81%e5%a4%9a%e7%ba%bf%e7%a8%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="100层楼只有2个鸡蛋想要判断出那一层刚好让鸡蛋碎掉给出策略">
  100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略
  <a class="heading-link" href="#100%e5%b1%82%e6%a5%bc%e5%8f%aa%e6%9c%892%e4%b8%aa%e9%b8%a1%e8%9b%8b%e6%83%b3%e8%a6%81%e5%88%a4%e6%96%ad%e5%87%ba%e9%82%a3%e4%b8%80%e5%b1%82%e5%88%9a%e5%a5%bd%e8%ae%a9%e9%b8%a1%e8%9b%8b%e7%a2%8e%e6%8e%89%e7%bb%99%e5%87%ba%e7%ad%96%e7%95%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="毒药问题1000瓶水其中有一瓶可以无限稀释的毒药要快速找出哪一瓶有毒需要几只小白鼠">
  毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠
  <a class="heading-link" href="#%e6%af%92%e8%8d%af%e9%97%ae%e9%a2%981000%e7%93%b6%e6%b0%b4%e5%85%b6%e4%b8%ad%e6%9c%89%e4%b8%80%e7%93%b6%e5%8f%af%e4%bb%a5%e6%97%a0%e9%99%90%e7%a8%80%e9%87%8a%e7%9a%84%e6%af%92%e8%8d%af%e8%a6%81%e5%bf%ab%e9%80%9f%e6%89%be%e5%87%ba%e5%93%aa%e4%b8%80%e7%93%b6%e6%9c%89%e6%af%92%e9%9c%80%e8%a6%81%e5%87%a0%e5%8f%aa%e5%b0%8f%e7%99%bd%e9%bc%a0">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="先手必胜策略问题100本书每次能够拿1-5本怎么拿能保证最后一次是你拿">
  先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿
  <a class="heading-link" href="#%e5%85%88%e6%89%8b%e5%bf%85%e8%83%9c%e7%ad%96%e7%95%a5%e9%97%ae%e9%a2%98100%e6%9c%ac%e4%b9%a6%e6%af%8f%e6%ac%a1%e8%83%bd%e5%a4%9f%e6%8b%bf1-5%e6%9c%ac%e6%80%8e%e4%b9%88%e6%8b%bf%e8%83%bd%e4%bf%9d%e8%af%81%e6%9c%80%e5%90%8e%e4%b8%80%e6%ac%a1%e6%98%af%e4%bd%a0%e6%8b%bf">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="放n只蚂蚁在一条树枝上蚂蚁与蚂蚁之间碰到就各自往反方向走问总距离或者时间">
  放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。
  <a class="heading-link" href="#%e6%94%ben%e5%8f%aa%e8%9a%82%e8%9a%81%e5%9c%a8%e4%b8%80%e6%9d%a1%e6%a0%91%e6%9e%9d%e4%b8%8a%e8%9a%82%e8%9a%81%e4%b8%8e%e8%9a%82%e8%9a%81%e4%b9%8b%e9%97%b4%e7%a2%b0%e5%88%b0%e5%b0%b1%e5%90%84%e8%87%aa%e5%be%80%e5%8f%8d%e6%96%b9%e5%90%91%e8%b5%b0%e9%97%ae%e6%80%bb%e8%b7%9d%e7%a6%bb%e6%88%96%e8%80%85%e6%97%b6%e9%97%b4">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="瓶子换饮料问题1000瓶饮料3个空瓶子能够换1瓶饮料问最多能喝几瓶">
  瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶
  <a class="heading-link" href="#%e7%93%b6%e5%ad%90%e6%8d%a2%e9%a5%ae%e6%96%99%e9%97%ae%e9%a2%981000%e7%93%b6%e9%a5%ae%e6%96%993%e4%b8%aa%e7%a9%ba%e7%93%b6%e5%ad%90%e8%83%bd%e5%a4%9f%e6%8d%a21%e7%93%b6%e9%a5%ae%e6%96%99%e9%97%ae%e6%9c%80%e5%a4%9a%e8%83%bd%e5%96%9d%e5%87%a0%e7%93%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="在24小时里面时针分针秒针可以重合几次">
  在24小时里面时针分针秒针可以重合几次
  <a class="heading-link" href="#%e5%9c%a824%e5%b0%8f%e6%97%b6%e9%87%8c%e9%9d%a2%e6%97%b6%e9%92%88%e5%88%86%e9%92%88%e7%a7%92%e9%92%88%e5%8f%af%e4%bb%a5%e9%87%8d%e5%90%88%e5%87%a0%e6%ac%a1">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="生成随机数问题给定生成1到5的随机数rand5如何得到生成1到7的随机数函数rand7">
  生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？
  <a class="heading-link" href="#%e7%94%9f%e6%88%90%e9%9a%8f%e6%9c%ba%e6%95%b0%e9%97%ae%e9%a2%98%e7%bb%99%e5%ae%9a%e7%94%9f%e6%88%901%e5%88%b05%e7%9a%84%e9%9a%8f%e6%9c%ba%e6%95%b0rand5%e5%a6%82%e4%bd%95%e5%be%97%e5%88%b0%e7%94%9f%e6%88%901%e5%88%b07%e7%9a%84%e9%9a%8f%e6%9c%ba%e6%95%b0%e5%87%bd%e6%95%b0rand7">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="蓄水池采样算法">
  蓄水池采样算法
  <a class="heading-link" href="#%e8%93%84%e6%b0%b4%e6%b1%a0%e9%87%87%e6%a0%b7%e7%ae%97%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="赛马有25匹马每场比赛只能赛5匹至少要赛多少场才能找到最快的3匹马">
  赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？
  <a class="heading-link" href="#%e8%b5%9b%e9%a9%ac%e6%9c%8925%e5%8c%b9%e9%a9%ac%e6%af%8f%e5%9c%ba%e6%af%94%e8%b5%9b%e5%8f%aa%e8%83%bd%e8%b5%9b5%e5%8c%b9%e8%87%b3%e5%b0%91%e8%a6%81%e8%b5%9b%e5%a4%9a%e5%b0%91%e5%9c%ba%e6%89%8d%e8%83%bd%e6%89%be%e5%88%b0%e6%9c%80%e5%bf%ab%e7%9a%843%e5%8c%b9%e9%a9%ac">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="烧-香绳子其他-确定时间问题有两根不均匀的香燃烧完都需要一个小时问怎么确定15分钟的时长">
  烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？
  <a class="heading-link" href="#%e7%83%a7-%e9%a6%99%e7%bb%b3%e5%ad%90%e5%85%b6%e4%bb%96-%e7%a1%ae%e5%ae%9a%e6%97%b6%e9%97%b4%e9%97%ae%e9%a2%98%e6%9c%89%e4%b8%a4%e6%a0%b9%e4%b8%8d%e5%9d%87%e5%8c%80%e7%9a%84%e9%a6%99%e7%87%83%e7%83%a7%e5%ae%8c%e9%83%bd%e9%9c%80%e8%a6%81%e4%b8%80%e4%b8%aa%e5%b0%8f%e6%97%b6%e9%97%ae%e6%80%8e%e4%b9%88%e7%a1%ae%e5%ae%9a15%e5%88%86%e9%92%9f%e7%9a%84%e6%97%b6%e9%95%bf">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="掰巧克力问题-nm块巧克力每次掰一块的一行或一列掰成11的巧克力需要多少次1000个人参加辩论赛1v1输了就退出需要安排多少场比赛快手提前批">
  掰巧克力问题 NM块巧克力，每次掰一块的一行或一列，掰成11的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）（快手提前批）
  <a class="heading-link" href="#%e6%8e%b0%e5%b7%a7%e5%85%8b%e5%8a%9b%e9%97%ae%e9%a2%98-nm%e5%9d%97%e5%b7%a7%e5%85%8b%e5%8a%9b%e6%af%8f%e6%ac%a1%e6%8e%b0%e4%b8%80%e5%9d%97%e7%9a%84%e4%b8%80%e8%a1%8c%e6%88%96%e4%b8%80%e5%88%97%e6%8e%b0%e6%88%9011%e7%9a%84%e5%b7%a7%e5%85%8b%e5%8a%9b%e9%9c%80%e8%a6%81%e5%a4%9a%e5%b0%91%e6%ac%a11000%e4%b8%aa%e4%ba%ba%e5%8f%82%e5%8a%a0%e8%be%a9%e8%ae%ba%e8%b5%9b1v1%e8%be%93%e4%ba%86%e5%b0%b1%e9%80%80%e5%87%ba%e9%9c%80%e8%a6%81%e5%ae%89%e6%8e%92%e5%a4%9a%e5%b0%91%e5%9c%ba%e6%af%94%e8%b5%9b%e5%bf%ab%e6%89%8b%e6%8f%90%e5%89%8d%e6%89%b9">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="介绍一下hadoop">
  介绍一下Hadoop
  <a class="heading-link" href="#%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bhadoop">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="说一下mapreduce的运行机制">
  说一下MapReduce的运行机制
  <a class="heading-link" href="#%e8%af%b4%e4%b8%80%e4%b8%8bmapreduce%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="消息队列是什么">
  消息队列是什么
  <a class="heading-link" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="为什么kafka吞吐量高介绍一下零拷贝">
  为什么kafka吞吐量高？/介绍一下零拷贝
  <a class="heading-link" href="#%e4%b8%ba%e4%bb%80%e4%b9%88kafka%e5%90%9e%e5%90%90%e9%87%8f%e9%ab%98%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b%e9%9b%b6%e6%8b%b7%e8%b4%9d">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="spark是什么">
  spark是什么
  <a class="heading-link" href="#spark%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="kafka如何选举leader">
  kafka如何选举leader
  <a class="heading-link" href="#kafka%e5%a6%82%e4%bd%95%e9%80%89%e4%b8%beleader">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="斐波那契数列第n项olog-n求出">
  斐波那契数列第n项，O(log n)求出
  <a class="heading-link" href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97%e7%ac%acn%e9%a1%b9olog-n%e6%b1%82%e5%87%ba">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="react的特点以及数据流向diff算法主要做了啥">
  react的特点以及数据流向，diff算法主要做了啥？
  <a class="heading-link" href="#react%e7%9a%84%e7%89%b9%e7%82%b9%e4%bb%a5%e5%8f%8a%e6%95%b0%e6%8d%ae%e6%b5%81%e5%90%91diff%e7%ae%97%e6%b3%95%e4%b8%bb%e8%a6%81%e5%81%9a%e4%ba%86%e5%95%a5">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="内存为什么要分段分段就只是为了方便程序员吗">
  内存为什么要分段？分段就只是为了方便程序员吗？
  <a class="heading-link" href="#%e5%86%85%e5%ad%98%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%86%e6%ae%b5%e5%88%86%e6%ae%b5%e5%b0%b1%e5%8f%aa%e6%98%af%e4%b8%ba%e4%ba%86%e6%96%b9%e4%be%bf%e7%a8%8b%e5%ba%8f%e5%91%98%e5%90%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="https可以防止dns劫持吗">
  https可以防止DNS劫持吗？
  <a class="heading-link" href="#https%e5%8f%af%e4%bb%a5%e9%98%b2%e6%ad%a2dns%e5%8a%ab%e6%8c%81%e5%90%97">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="设计一款聊天软件你打算采用什么方案">
  设计一款聊天软件，你打算采用什么方案？
  <a class="heading-link" href="#%e8%ae%be%e8%ae%a1%e4%b8%80%e6%ac%be%e8%81%8a%e5%a4%a9%e8%bd%af%e4%bb%b6%e4%bd%a0%e6%89%93%e7%ae%97%e9%87%87%e7%94%a8%e4%bb%80%e4%b9%88%e6%96%b9%e6%a1%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="cpu3级缓存">
  cpu3级缓存
  <a class="heading-link" href="#cpu3%e7%ba%a7%e7%bc%93%e5%ad%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="快表tlb是什么">
  快表（TLB）是什么
  <a class="heading-link" href="#%e5%bf%ab%e8%a1%a8tlb%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="http无状态优劣cookie">
  http无状态优劣—cookie
  <a class="heading-link" href="#http%e6%97%a0%e7%8a%b6%e6%80%81%e4%bc%98%e5%8a%a3cookie">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="什么是局部性原理">
  什么是局部性原理
  <a class="heading-link" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b1%80%e9%83%a8%e6%80%a7%e5%8e%9f%e7%90%86">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="rabbitmq怎么用的">
  rabbitMQ怎么用的
  <a class="heading-link" href="#rabbitmq%e6%80%8e%e4%b9%88%e7%94%a8%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="redis怎么用的">
  redis怎么用的
  <a class="heading-link" href="#redis%e6%80%8e%e4%b9%88%e7%94%a8%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="数据库中哪些地方用了链表">
  数据库中哪些地方用了链表
  <a class="heading-link" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e5%93%aa%e4%ba%9b%e5%9c%b0%e6%96%b9%e7%94%a8%e4%ba%86%e9%93%be%e8%a1%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="http了解吗怎么样不用框架用原生语言解析请求的json数据">
  HTTP了解吗，怎么样不用框架用原生语言解析请求的Json数据
  <a class="heading-link" href="#http%e4%ba%86%e8%a7%a3%e5%90%97%e6%80%8e%e4%b9%88%e6%a0%b7%e4%b8%8d%e7%94%a8%e6%a1%86%e6%9e%b6%e7%94%a8%e5%8e%9f%e7%94%9f%e8%af%ad%e8%a8%80%e8%a7%a3%e6%9e%90%e8%af%b7%e6%b1%82%e7%9a%84json%e6%95%b0%e6%8d%ae">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="怎么样用数据结构和算法写一个定时器">
  怎么样用数据结构和算法写一个定时器
  <a class="heading-link" href="#%e6%80%8e%e4%b9%88%e6%a0%b7%e7%94%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%92%8c%e7%ae%97%e6%b3%95%e5%86%99%e4%b8%80%e4%b8%aa%e5%ae%9a%e6%97%b6%e5%99%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="tcp是怎么样超时重传的">
  tcp是怎么样超时重传的
  <a class="heading-link" href="#tcp%e6%98%af%e6%80%8e%e4%b9%88%e6%a0%b7%e8%b6%85%e6%97%b6%e9%87%8d%e4%bc%a0%e7%9a%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="mqtt">
  MQTT
  <a class="heading-link" href="#mqtt">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="webserver-项目中如果所有线程都在工作收到请求怎么做">
  webserver 项目中如果所有线程都在工作，收到请求怎么做？
  <a class="heading-link" href="#webserver-%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e6%9e%9c%e6%89%80%e6%9c%89%e7%ba%bf%e7%a8%8b%e9%83%bd%e5%9c%a8%e5%b7%a5%e4%bd%9c%e6%94%b6%e5%88%b0%e8%af%b7%e6%b1%82%e6%80%8e%e4%b9%88%e5%81%9a">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="python-routine">
  python routine
  <a class="heading-link" href="#python-routine">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="自己写一个协程控制器包括添加协程暂停等功能">
  自己写一个协程控制器，包括添加协程，暂停等功能
  <a class="heading-link" href="#%e8%87%aa%e5%b7%b1%e5%86%99%e4%b8%80%e4%b8%aa%e5%8d%8f%e7%a8%8b%e6%8e%a7%e5%88%b6%e5%99%a8%e5%8c%85%e6%8b%ac%e6%b7%bb%e5%8a%a0%e5%8d%8f%e7%a8%8b%e6%9a%82%e5%81%9c%e7%ad%89%e5%8a%9f%e8%83%bd">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="写个生产者消费者模型">
  写个生产者消费者模型
  <a class="heading-link" href="#%e5%86%99%e4%b8%aa%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e6%a8%a1%e5%9e%8b">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="线程安全的数据结构">
  线程安全的数据结构
  <a class="heading-link" href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="线程池的创建方法">
  线程池的创建方法
  <a class="heading-link" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%88%9b%e5%bb%ba%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="c反射是什么">
  C++反射是什么
  <a class="heading-link" href="#c%e5%8f%8d%e5%b0%84%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="https加密协商出来的密钥的类型是什么">
  https加密协商出来的密钥的类型是什么
  <a class="heading-link" href="#https%e5%8a%a0%e5%af%86%e5%8d%8f%e5%95%86%e5%87%ba%e6%9d%a5%e7%9a%84%e5%af%86%e9%92%a5%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h2 id="海量数据问题">
  海量数据问题
  <a class="heading-link" href="#%e6%b5%b7%e9%87%8f%e6%95%b0%e6%8d%ae%e9%97%ae%e9%a2%98">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><a href="https://wangpengcheng.github.io/2019/12/17/hailiangshuju_problems/"  class="external-link" target="_blank" rel="noopener">https://wangpengcheng.github.io/2019/12/17/hailiangshuju_problems/</a></p>
<h2 id="c问题大全">
  C++问题大全
  <a class="heading-link" href="#c%e9%97%ae%e9%a2%98%e5%a4%a7%e5%85%a8">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><a href="https://zhuanlan.zhihu.com/p/603532168"  class="external-link" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/603532168</a></p>

      </div>


      <footer>
        


        
        
        <div class="comments">
    <script>
  
    let getTheme = window.localStorage && window.localStorage.getItem("colorscheme");
  
    getTheme = getTheme == null ? 'github-light' : getTheme;
    
    let theme = getTheme === 'dark' ? 'github-dark' : 'github-light';
    let s = document.createElement('script');
    s.src = 'https://utteranc.es/client.js';
    s.setAttribute('repo', 'oyyko\/utteranc-comments');
    s.setAttribute('issue-term', 'pathname');
    s.setAttribute('theme', theme);
    s.setAttribute('crossorigin', 'anonymous');
    s.setAttribute('async', '');
    document.querySelector('div.comments').innerHTML = '';
    document.querySelector('div.comments').appendChild(s);
  
    </script>
    </div>
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
    <section class="container">
      ©
      
      2019 -
      
      2024
       Oyyko 
      ·
      
      Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a
        href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a> Modified by <a
        href="https://oyyko.com" target="_blank" rel="noopener">Oyyko </a>.
      
    </section>
</footer>
  </main>

  

  
  
  <script src="/blog-coder-copy/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
